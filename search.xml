<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小米固件工具mkxqimage]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%B0%8F%E7%B1%B3%E5%9B%BA%E4%BB%B6%E5%B7%A5%E5%85%B7mkxqimage%2F</url>
    <content type="text"><![CDATA[小米固件工具mkxqimage小米自己改了个打包解包固件的工具，基于 trx 改的（本质上还是 trx 格式），加了 RSA 验证和解包功能，路由系统里自带：1234Usage:mkxqimg [-o outfile] [-p private_key] [-f file] [-f file [-f file [-f file ]]] [-x file] [-I] 固件解包固件工具mkxqimage完成对固件的解包，在解包前先检查Checksum是否正确，然后利用RSA公钥/usr/share/xiaoqiang/public.pem检查RSA签名，这两个步骤通过后，根据[0x0C]的固件类型，以及[0x10]、[0x14]、[0x18]和[0x1C]的4个偏移量拆分固件。 固件打包小米官方在打包固件时用RSA私钥计算出固件的RSA签名，小米路由器下载固件后用RSA公钥来验证RSA签名，有效地防止固件被篡改。 固件格式路由固件的格式，基本是基于 openwrt 的 trx 这个简单的二进制文件格式12348 44 52 30 63 D4 11 03 FE 3D 1A FD 05 00 02 0020 00 00 00 20 00 FE 00 00 00 00 00 00 00 00 00FF 04 00 EA 14 F0 9F E5 14 F0 9F E5 14 F0 9F E5 第1～4字节：ASCII字符串“HDR0”，作为固件的标识；第5～8字节：4字节整型数0x0311D464，表示固件的大小：51500132字节；第9~12字节：固件的检查和；第13～14字节：0x0005，表示固件中包含哪些部分；第15～16字节：0x0002，表示固件格式版本号；第17～20字节：0x00000020，表示固件第一部分在整个固件中的偏移量，0.4.85固件的第一部分是brcm4709_nor.bin，也就是Flash中除0xfe0000-0xff0000的board_data外的全镜像；第21～24字节：0x00FE0020，表示固件第二部分在整个固件中的偏移量，0.4.85固件的第二部分是root.ext4.lzma，也就是硬盘中128M固件的压缩包；第33字节开始是固件的正式内容开始。 小米开启ssh工具包使用mkxqimage解包（现在会提示秘钥不存在）12error fopen public keyImage verify failed, not formal image 如果能解包应该可以得到脚本文件upsetting.sh 1234#!/bin/shnvram set ssh_en=1nvram set flag_init_root_pwd=1nvram commit 执行脚本文件upsetting.sh后，将ssh_en设置为1，同时设置了flag_init_root_pwd项。当正式启动时，/usr/sbin/boot_check脚本检测到flag_init_root_pwd=1时，自动修改root用户密码，具体脚本为：1234567flg_init_pwd=`nvram get flag_init_root_pwd`if [ &quot;$flg_init_pwd&quot; = &quot;1&quot; ]; then init_pwd=`mkxqimage -I` (echo $init_pwd; sleep 1; echo $init_pwd) | passwd root nvram unset flag_init_root_pwd nvram commitfi 初始密码是mkxqimage -I的结果，实际是根据路由器的序列号计算得到。路由器的序列号印在底盖上，12位数字，如：561000088888 初始密码计算算法为： substr(md5(SN+&quot;A2E371B0-B34B-48A5-8C40-A7133F3B5D88&quot;), 0, 8) A2E371B0-B34B-48A5-8C40-A7133F3B5D88 为分析mkxqimage得到的salt]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>小米</tag>
        <tag>文件格式</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ数据库的加密与解密]]></title>
    <url>%2F2019%2F02%2F22%2Fqq%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[qq数据库采用简单加密——异或加密数据获取：DENGTA_META.xml—IMEI:867179032952446databases/2685371834.db——数据库文件 解密方式：明文msg_t 密文msg_Data key：IMEImsg_t = msg_Data[i]^IMEI[i%15] 实验：123456789101112131415161718192021222324import sqlite3IMEI = &apos;867179032952446&apos;conn = sqlite3.connect(&apos;2685371834.db&apos;)c = conn.cursor()def _decrypt(foo): substr = &apos;&apos; #print(len(foo)) for i in range(0,len(foo)): substr += chr(ord(foo[i]) ^ ord(IMEI[i%15])) return substr#rem = c.execute(&quot;SELECT uin, remark, name FROM Friends&quot;)Msg = c.execute(&quot;SELECT msgData, senderuin, time FROM mr_friend_0FC9764CD248C8100C82A089152FB98B_New&quot;)for msg in Msg: uid = _decrypt(msg[1]) print(&quot;\n&quot;+uid+&quot;:&quot;) try: msgData = _decrypt(msg[0]).decode(&apos;utf-8&apos;) print(msgData) except: pass 结果]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>QQ</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wifi半双工侧信道攻击学习笔记]]></title>
    <url>%2F2019%2F01%2F16%2Fwifi%E5%8D%8A%E5%8F%8C%E5%B7%A5%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TCP侧信道分析及利用的学习报告背景知识测信道香农信息论 什么是信息？ 用来减少随机不确定的东西 什么是加密？ 类似于加噪声，增加随机不确定性 “从密码分析者来看，一个保密系统几乎就是一个通信系统。待传的消息是统计事件，加密所用的密钥按概率选出，加密结果为密报，这是分析者可以利用的，类似于受扰信号。” 侧信道随之出现 越过加密算法增加的随机不定性，从其他的渠道获取数据标签，确定信息内容。 早期：采集加密电子设备在运行过程中的时间消耗、功率消耗或者电磁辐射消耗等边缘信息的差异性 而随着研究的深入，逐渐从加密设备延伸到计算机内部CPU、内存等之间的信息传递 并在Web应用交互信息传递越来越频繁时，延伸到了网络加密数据流的破解方面 侧信道攻击的流程 第一个就是侧信道泄露的截取，第二个是信息的恢复。 网络攻击 中间人攻击 “指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。” 公共wifi、路由器劫持 一般使用加密来防御 加密的代价：维护密钥证书、影响功能（运营商无法做缓存） 非中间人攻击/偏离路径攻击/off-path attack 通信线路之外，攻击者看不到双方的消息，没办法截获和发送通信包。智能伪造成一方给另一方发消息。 攻击成功需要：消息合法+最先到达 防御措施：challenge-response/询问-应答机制双方在通信前交换一个随机数，这个随机数在每次的通信中都要被附带，而中间人看不见这个随机数，因此伪造的消息被认为不合法。 攻击者如何得到这个随机数：侧信道 TCP三次握手 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数A。 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。 最后，客户端再发送一个ACK。当服务端收到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包的序号被设定为收到的确认号A+1，而响应号则为B+1。 通过三次握手，确定对方不是非中间人 TCP序列号的问题 1985 1995 2001 2004 2007 2012 2012 2016 Morris Mitnik Zalewsky Waston kLM Herzberg 作者 作者 初始序列可预测 真实利用 漏洞仍在 BGP DoS Windows攻击 Puppet-assisted Malware-assisted off-path attack 90年代时发现并不随机：1995年伪造客户端连接微软大楼的服务器 2007年在windows场景下用IDID侧信道猜出序列号：只针对Windows，花费几小时 Malware-assisted攻击模型：给受害者安装一个无特权的应用程序（仅能网络连接），这个程序跟非中间人的攻击者里应外合，劫持手机上所有的TCP连接。 如何劫持TCP 需要的信息：Facebook的连接IP地址和端口号，由此可以知道TCP连接的序列号，利用序列号伪装成Facebook给手机发消息。使用netstat命令获取： 任务：由于TCP的序列号通常连续，所以要精确猜到它的下一个序列号。 如何验证序列号正确：通过某种侧信道，这个恶意软件在后台可以提供反馈。 变种一：防火墙攻击过程： TCP三次握手之后产生A和B，将来传输的包序列号必须跟A和B很接近，否则，防火墙会丢弃这个包。因此只有猜对了序列号，包才能到达手机端。到达手机端后，后台的恶意软件可以帮助我们判断手机是否接受了这个数据包。 具体侧信道方案： CPU资源使用率（噪音很大）——&gt;TCP计数器（后台软件运行制造噪音）——&gt;低噪音计数器：包被丢掉时，一个相应的错误计数器。 解决方法： 关闭防火墙检查序列号的功能 变种二：无防火墙具体侧信道方案：跟TCP业务逻辑有关的计数器——收到的TCP包序列号小于期望时增加，大于时不变。二分查找搜索正确的序列号。影响范围：Android、Linux、MacOS、FreeBSD Pure off-path:无恶意软件协助 不植入恶意软件，劫持任意两台机器的TCP连接：首先确定是否建立TCP连接，然后推测其序列号A和B。 Global Rate Limit USENIX 2016 : Off-Path TCP Exploits: Global Rate Limit Considered Dangerous 侧信道： 所有的侧信道，本质上就是攻击者和受害者之间共享着某些资源，如之前的全局TCP计数器。这里使用的侧信道是 服务器上 的共享资源，限速器（RFC 5961）限制某一种包的发送速率（默认100p/s） 如何利用共享限速器：先判断是否建立了连接。然后伪造TCP包，需要猜测源端口，如果猜测正确，服务器会返回一个challenge，攻击者不断触发，一共可以收到99个（还有一个发给了客户端）；如果猜测错误，则一共可以收到100个challenge。 评估： 是否建立了连接：&lt;10s ; Seq：30s ； ACK:&lt;10s 解决方案： 1. 加噪音，100变成150、200；2. 限速器做成局部的 Unfixable WiFi timing USENIX 2018 : Off-Path TCP Exploit: How Wireless RoutersCan Jeopardize Your Secrets之前的漏洞无论是计数器还是限速器都属于软件，很好更正，但这篇文章的漏洞利用无法修复。 TCP收包的原理： 通常TCP收包要看这个包是否匹配了当前的某一个连接。如果连接匹配上了，就会去看这个包的序列号；如果序列号不对，会触发一个回复，说明这个序列号存在问题；如果序列号正确，但反向序列号不对，也会丢包。当连接匹配、序列号和反向序列号正确时，就会返回一个数据包。 侧信道： 攻击者伪装成服务器给客户端发包，正确的序列号会有回复，错误则没有。但回复时发送给服务器的，有没有回复攻击者并不知道。那么如何去判断有没有回复，利用无线网络的 半双工 传输。让有回包和没有回包的时间差异放大。 判断流程： 客户端和路由器之间wifi通信。攻击者依次发送三个数据包，第一个包用来测试正常的RTT。第2个包是伪装成服务器发送的，如果第2个包猜对了，客户端会向服务器返回数据包，这会导致占用更长时间的wifi信道，从而会使第3个包的RTT更长。 评估： 在本地环境下，如果发送40个包，就有20ms的RTT差别。 攻击应用：1. 攻击模型： 受害者访问了我们的钓鱼网站，这时javascript（傀儡）会在后台执行，主动建立到攻击者的连接（规避NAT或防火墙造成的不可抵达问题），这时攻击者就可以从外网测试RTT。 与理想情况的不同：客户端通常在NAT或防火墙之后；操作系统不一定严格遵守TCP收包的原则 Attacker -------wire----------| Router ---------wireless-------Victim (client) Server -------wire----------| 2. 攻击目标： 推断出客户端和服务器是否建立了连接；合计连接中交换的字节数或强制中断连接；注入恶意payload到连接（不失一般性的关注web缓存投毒）。前两个不需要傀儡初始化连接，第三个不一定需要，但攻击者控制了时序，能够简化攻击。 3. 攻击过程： 假设傀儡已经建立了连接，攻击者可以劫持并替换任何不加密的网站（如武汉大学），并在浏览器缓存。这是因为当浏览器请求相同的ip地址时，会复用之前的TCP连接。这意味着恶意网站中的傀儡可以通过重复HTML元素来建立到目标域名的单个持久连接。然后，路径外攻击者可以进行侧信道攻击，以推断目标连接中使用的端口号和序列号，然后注入虚假的http响应，并要求浏览器不重新检查对象的新鲜度，从而达到持续性的缓存投毒。 4. 细节： 连接（四元组）推断： 每一轮使用30个重复包测试一个端口，如果端口号正确，就会发现RTT大幅增加。如果还要完成 web缓存投毒 ，还需要傀儡初始化连接来协助，根据系统不同，有不同的端口选择算法可以优化：windows&amp;macOS 使用全局和顺序端口分配策略为其TCP连接选择短暂的端口号，这意味着攻击者可以在观察到与恶意Web服务器的初始连接后推断出要使用的下一个端口号，这完全消除了对端口号推断的需要。NAT 端口保留，不需要关心外部端口被转换成不可预知的内部端口。来自同一域名的多个IP地址，这意味着攻击者需要付出更大的代价来推断端口号。 序列号推断： 通过利用时序侧信道来判断是否存在相应的响应，从而将窗口序列号与窗外序列号区分开来。一旦我们得到一个 窗口内序列号，通过进行二分搜索进一步将序列号空间缩小到单个值 RCV.NXT。如果还要使用傀儡建立的连接发起web缓存投毒，可以进一步优化：增大接收窗口的大小，可以减少猜测的迭代次数，通常可以放大到500000(之前是65535)，而且根据RFC793,窗口放大之后就永远不会缩小。 TCP劫持： 通过劫持傀儡初始化的连接，可以简化web缓存投毒的过程。三个os在ACK验证上都不符合规范，所以各自处理情况也不同——windows：客户端必须持续发送请求以防止ACK接收窗口仅为一个字节，这要求攻击者必须能准确预期下一个序列号并解决大量流量带来的噪声。因此，作者设计了一种新策略，该策略利用处理重叠数据的TCP行为和处理损坏的HTTP响应的浏览器行为——在Windows主机上缓冲的攻击者注入数据可能会破坏来自服务器的真实HTTP响应。 （1）注入，傀儡不断从服务器上请求脚本，而攻击者发送2^23/|wnd|个欺骗性数据包，这些包的窗口序列号与RCV.NXT加上偏移量相匹配，其中|wnd|为ack接收窗口大小，第i个数据包的ACK号为i*|wnd|，payload为 1websocket.send(|wnd|*i) 因此，这些数据包中包含有效ACK号的一个包将被缓冲，并破坏真实的HTTP响应头。浏览器执行注入的脚本时，它将通过websocket发送猜测的ACK号，提供有效的窗口内ACK号。（2）利用，由于客户端已经接受了额外的欺骗payload，推进了其预期的序列号，因此客户端和服务器实际上已经被去同步。攻击者现在可以简单地发送欺骗性响应（知道预期的序列号和有效的ACK号）。如果我们只想执行一次性注入，只需用恶意脚本替换第一步中的payload就足够了。此外，针对Windows的注入步骤存在更加通用的替代策略，不依赖于浏览器行为。 具体来说，由于HTTP响应的前几个字节是可预先确定的（即HTTP），不破坏真实的响应，而是覆盖标题和正文以形成合法但恶意的响应。 在这种情况下，浏览器将完全忘记注入的存在。 这表明一旦序列号泄露，就存在各种方法来有效地将数据注入浏览器，而不用进行基于时间信道的慢得多的ACK号推断。 Discussion时序侧信道来自无线网络的半双工性质。由于无线协议中固有的冲突和回退，它被进一步放大。正如我们的测试路由器所证实的那样，现代无线路由器都支持CSMA / CA和RTS / CTS，因为它是802.11标准的一部分，并且该原则不太可能很快改变。虽然作者只讨论威胁模型，其中来自受害客户端的连接是针对性的，但攻击实际上也适用于源自通过同一无线路由器连接的其他客户端的连接。这是因为所有这些客户端（例如，在相同NAT之后）共享了相同的冲突域并因此遭受相同的定时信道。通过探测数据包在任何客户端上触发的响应将有效地延迟探测后查询。在这种情况下，受害者连接（通过傀儡打开）只是为远程攻击者提供了测量碰撞的机会。此外，我们可以扩展威胁模型以考虑无线连接的服务器，例如物联网设备。已经证明，通过公共IP地址和开放端口可以访问数百万个物联网设备。在这种情况下，可以针对此类IoT设备上的连接启动完全偏离路径的攻击。例如，计算在连接上交换的字节，终止与另一主机的连接，在正在进行的telnet连接上注入恶意命令。]]></content>
      <categories>
        <category>顶会论文</category>
      </categories>
      <tags>
        <tag>侧信道攻击</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python实现BIBA模型]]></title>
    <url>%2F2018%2F11%2F16%2FBIBA%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0(python)%2F</url>
    <content type="text"><![CDATA[基于python语言的BIBA模型图形界面实现一、实验目的： 查阅资料，了解biba安全模型的相关知识 通过编程实现基于biba模型的完整性访问控制，进一步掌握biba模型的规则 使用python语言实现，熟练pyqt的图形界面设计方法 二、实验环境： 操作系统：Windows10 工具版本：python3.7，pyqt5 三、实验原理：1. 什么是安全模型 系统的元素 具有行为能力的主体不具有行为能力的客体 系统的操作行为 可以执行的命令：读、写、执行 对系统行为的约束方式 对行为的控制策略 模型从抽象层次规定了系统行为和约束行为的方式 模型往往用状态来表示 系统行为所依赖的环境行为对系统产生的效果 2. biba完整性模型： 完整性威胁问题 完整性的威胁就是一个子系统在初始时刻认为不正常的修改行为；来源：内部&amp;外部；类型：直接&amp;间接 外部的直接 外部的间接 内部的直接 内部的间接 外部系统恶意地篡改另一个系统的数据或程序 一个外部系统插入恶意的子程序 修改自己的代码 修改自己的指针 biba模型的完整性定义 完整性级别高的实体对完整性低的实体具有完全的支配性，反之如果一个实体对另一个实体具有完全的控制权，说明前者完整性级别更高，这里的实体既可以是主体也可以是客体。完整性级别和可信度有密切的关系，完整级别越高，意味着可信度越高。 biba模型的规则 对于写和执行操作，有如下规则： 写规则控制当且仅当主体S的完整性级别大于或等于客体O的完整性级别时，主体S可以写客体O,一般称之为上写。执行操作控制当且仅当主体S2的完整性级别高于或等于S1,主体S1可以执行主体S2。 关于读操作，有不同的控制策略： 低水标模型任意主体可以读任意完整性级别的客体，但是如果主体读完整性级别比自己低的客体时，主体的完整性级别将为客体完整性级别，否则，主体的完整性级别保持不变。环模型不管完整性级别如何，任何主体都可以读任何客体严格完整性模型这个模型对读操作是根据主客体的完整性级别严格控制的，即只有完整性级别低或相等的主体才可以读完整性级别高的客体，称为下读 一般都是指毕巴严格完整性模型，总结来说是上写、下读 四、实验内容：1. 用户登录实现核对用户输入的账户密码与存储的是否匹配 从用户输入框获取账户和密码 检查输入信息是否合法（为空） 从password.txt中获取，并保存在列表listFromLine中 检查输入的账户是否存在 若存在，检查对应的密码是否正确 若正确，判断是管理员还是普通用户，并跳转相应的界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344def checkPass(self): nameIn = self.lineEdit.text() passwdIn = self.lineEdit_2.text() md5 = hashlib.md5() md5.update(passwdIn.encode("utf-8")) passwdIn = md5.hexdigest() if (nameIn == '') or (passwdIn == ''): QMessageBox.warning(self, "警告", "账号和密码不能为空", QMessageBox.Yes) self.lineEdit.setFocus() print(nameIn, passwdIn) fr = open('./etc/passwd.txt') arrayofLines = fr.readlines() numberofLines = len(arrayofLines) for line in arrayofLines: line = line.strip() listFromLine = line.split(':') name = listFromLine[0] if name == nameIn: numberofLines = -1 passwd = listFromLine[1] if passwd == passwdIn: group = listFromLine[2] print("\n登录成功!\n") if name == 'root': print('root登录') rootUI.show() MainWindow.close() else: urName = nameIn mainUI.lineEdit.setText(urName) mainUI.lineEdit_2.setText(group) mainUI.show() MainWindow.close() else: QMessageBox.warning(self, "警告", "密码错误！", QMessageBox.Yes) self.lineEdit.setFocus() fr.close() return 0 2. 管理员功能实现管理员可以对用户进行增、删、查的操作 增加用户的实现 获取管理员输入的用户名、密码和用户等级 将明文密码转换为md5值 判断输入的账户是否已经存在以及是否为空 如果没有问题，将其存入passwd.txt的末尾 12345678910111213141516171819202122232425262728293031def adduser(self): print('开始添加') name = self.lineEdit_4.text() passwd = self.lineEdit_6.text() md5 = hashlib.md5() md5.update(passwd.encode("utf-8")) passwd = md5.hexdigest() group = self.comboBox.currentText() self.name = name if self.euxit(): if name == '' or passwd == '': QMessageBox.warning(self, "警告", "账号和密码不能为空", QMessageBox.Yes) self.lineEdit.setFocus() else: cur_path = os.getcwd() filename = cur_path + '/etc/passwd.txt' fi = open(filename, 'r+') str = name + ':' + passwd + ':' + group + '\n' print('成功增加用户' + str + '\n') fi.seek(0, 2) fi.write(str) fi.close() else: QMessageBox.warning(self, "警告", "用户已存在", QMessageBox.Yes) self.lineEdit.setFocus() 查询已有用户的实现 从passwd.txt中逐行读出 123456789101112def readuser(self): print('readuser') cur_path = os.getcwd() filename = cur_path + '/etc/passwd.txt' fo = open(filename) arrayofLines = fo.readlines() names = '' for line in arrayofLines: line = line.strip() listFromLine = line.split(':') names = names + listFromLine[0] + '\n' self.textEdit.setPlaceholderText(names) 删除用户的实现 从passwd.txt中逐行读出用户名，并与待删除用户比较，如果相同，则删除该行 12345678910111213141516171819def rmuser(self): print(1) cur_path = os.getcwd() filename = cur_path + '/etc/passwd.txt' rmName = self.lineEdit.text() with open(filename, 'r',encoding="utf-8") as r: lines = r.readlines() lenl = len(lines) with open(filename, 'w',encoding="utf-8") as w: for line in lines: l = line.strip() listFromLine = l.split(':') if rmName == listFromLine[0]: print('删除用户' + rmName) continue if line == '\n': print('find换行') line = '' w.write(line) 3. 普通用户功能实现普通用户可以完成对合法权限文件的读取、增加内容（上写下读）以及创建文件的操作 读取文件内容 双击文件名获取选中文件和当前用户的完整性级别如果用户的级别低于文件，则读取文件内容 123456789101112131415161718192021def readfile(self): dict = self.getGrade() fgrade = str(dict[self.file_path]) ugrade = self.lineEdit_2.text() if ugrade &gt;= fgrade: print(ugrade+ ' 正在读取 '+fgrade) filename = self.file_path print(filename) fr = open(filename) lines = '' arrayofLines = fr.readlines() for line in arrayofLines: lines += line self.textEdit.setText(lines) print('读取成功\n') else: QMessageBox.warning(self, "警告", "您的用户等级太高", QMessageBox.Yes) self.lineEdit.setFocus() 增加文件内容 双击文件名获取选中文件和当前用户的完整性级别如果用户的级别高于文件，则写入文件内容 123456789101112131415161718def writefile(self): dict = self.getGrade() fgrade = dict[self.file_path] ugrade = self.lineEdit_2.text() print(ugrade + ' 正在写入 ' + fgrade) if ugrade &lt;= fgrade: filename = self.file_path str = self.textEdit.toPlainText() print(str) fo = open(filename, 'r+') fo.seek(0, 2) fo.write(str) else: QMessageBox.warning(self, "警告", "您的用户等级太低", QMessageBox.Yes) self.lineEdit.setFocus() 创建文件 获取当前用户名和输入的文件名在当前路径下创建名为用户名的文件并对新创建的文件与用户等级建立字典，新文件路径为key，用户等级为value这个字典方便读写时判断等级高低 123456789101112131415161718192021222324def touchfile(self): urName = self.lineEdit.text() filename = self.lineEdit_4.text() cur_path = os.getcwd() new_path = os.path.join(cur_path + '/file', urName) print(urName) if os.path.exists(new_path) == False: os.mkdir(new_path) os.chdir(new_path) fr = open(filename, 'w') key = (new_path + '/' + filename).replace('\\', '/') fr.close() os.chdir(cur_path) fa = open('./etc/ac.txt', 'r') a = fa.read() if a == '': dict = &#123;&#125; else: dict = eval(a) dict[key] = self.lineEdit_2.text() fr = open('./etc/ac.txt', 'w') fr.write(str(dict)) fr.close() fa.close() 五、心得体会：六、改进部分：]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>模型实现</tag>
        <tag>python</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2000%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[你好！我是混元霹雳手]]></content>
  </entry>
</search>
